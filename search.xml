<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[希尔排序和二分查找]]></title>
    <url>%2F2018%2F05%2F22%2Falgorithm_1%2F</url>
    <content type="text"><![CDATA[希尔排序希尔排序是分组后的直接插入排序，它的效率比直接插入排序要高，是插入排序的改进版，当然最差也接近直接插入排序效率，而不会比它高，计算希尔排序的时间复杂度是个麻烦的事情，它和具体设置的增量有关，大量数据测试，平均值是 O(n^1.3) 增量按折半计算： 12345678910111213141516public static int[] shellSort(int[] datas)&#123; int count = datas.length; for(int gap = count / 2; gap &gt; 0 ; gap /= 2)&#123;//总共分组次数，每次都用插入排序 for(int i = gap; i &lt; count; i++)&#123; int j = i; while (j - gap &gt;= 0 &amp;&amp; datas[j] &lt; datas[j - gap])&#123; int temp = datas[j]; datas[j] = datas[j - gap]; datas[j-gap] = temp; j -= gap; &#125; &#125; &#125; return datas; &#125; 二分查找递归实现1234567891011public static int binarySearch(int[] results, int low, int high, int key)&#123; int mid = (low + high) / 2; if(results[mid] == key)&#123; return mid; &#125;else if(results[mid] &gt; key)&#123; return binarySearch(results, low, mid - 1,key); &#125;else if(results[mid] &lt; key)&#123; return binraySearch(results, mid + 1, high, key); &#125; return -1;&#125; 非递归实现123456789101112131415public static int binarySearch1(int[] results, int key)&#123; int low = 0; int high = results.length - 1; while(low &lt; high)&#123; int mid = (low + high) / 2; if(results[mid] == key)&#123; return mid; &#125;else if(results[mid] &gt; key)&#123; high = mid - 1; &#125;else if(results[mid] &lt; key)&#123; low = mid + 1; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习]]></title>
    <url>%2F2018%2F05%2F18%2Falgorithm%2F</url>
    <content type="text"><![CDATA[插入排序，冒泡排序，选择排序 插入排序： 有序序列中，怎么插入一个值的问题 冒泡排序：接力滚动选出最大（最小）值问题 选择排序：直接选出最大（最小）值问题 Python版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# coding:UTF-8import random# 随机数def get_andomNumber(num): lists=[] i=0 while i&lt;num: lists.append(random.randint(0,100)) i+=1 return lists# 插入排序def insert_sort(lists): for i in range(1,len(lists)): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j],lists[j+1] = key, lists[j] j -= 1 return lists#冒泡排序def buddle_sort(lists): count = len(lists) - 1 for i in range(0,count): for j in range(0,count-i-1): if lists[j] &gt; lists[j+1]: lists[j],lists[j+1] = lists[j+1],lists[j] return lists#选择排序def select_sort(lists): count = len(lists) - 1 for i in range(0,count): k = i; for j in range(k+1,count + 1): if lists[j] &lt; lists[k]: k = j if k != i: lists[k],lists[i] = lists[i],lists[k] return listsa = get_andomNumber(10)print(&quot;排序之前：%s&quot; %a)b = insert_sort(a)print(&quot;插入排序：%s&quot; %b)c = buddle_sort(a)print(&quot;冒泡排序：%s&quot; %c)m = select_sort(a)print(&quot;冒泡排序：%s&quot; %m)#时间复杂度f(n) = 1 + 2 + ...+n-1 = n^2/ 2 - n/2,所以O(f(n)) = n^2 Java 版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import javax.sound.midi.Soundbank;import java.util.Random;/** * Created by zhanghailiang on 18/5/20. */public class SortUtil &#123; public static int[] random()&#123; int count = 10; int[] datas = new int[count]; for(int i = 0; i &lt; count; i++)&#123; datas[i] = new Random().nextInt(98) + 1; System.out.print(datas[i] + " "); &#125; return datas; &#125; public static int[] insertSort(int[] datas)&#123; int count = datas.length; for(int i = 0; i &lt; count - 1; i++)&#123; int j = i; while (j &gt;= 0)&#123; if(datas[j + 1] &lt; datas[j])&#123; int temp = datas[j + 1]; datas[j + 1] = datas[j]; datas[j] = temp; &#125; j--; &#125; &#125; return datas; &#125; public static int[] buddleSort(int[] datas) &#123; int count = datas.length; for(int i = 0; i &lt; count - 1; i++)&#123; for(int j = 0; j &lt; count - i - 1; j++)&#123; if(datas[j] &gt; datas[j+1])&#123; int temp = datas[j + 1]; datas[j + 1] = datas[j]; datas[j] = temp; &#125; &#125; &#125; return datas; &#125; //非相临交换 public static int[] selecSort(int[] datas)&#123; int count = datas.length; for(int i = 0; i &lt; count - 1; i++)&#123; int min = i; for(int j = i+1; j &lt; count; j++)&#123; if(datas[j] &lt; datas[min])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = datas[min]; datas[min] = datas[i]; datas[i] = temp; &#125; &#125; return datas; &#125; public static void main(String[] args) &#123; int[] datas = SortUtil.random(); int[] results = SortUtil.selecSort(datas); System.out.printf("\r\n"); for(int i = 0; i &lt; results.length; i++)&#123; System.out.printf(results[i] + " "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker vs vps]]></title>
    <url>%2F2018%2F05%2F18%2Fdocker_1%2F</url>
    <content type="text"><![CDATA[Docker vs vpsThe perspective on containers is very different between the 2. In short OpenVZ sees a container as a VPS, and docker sees a container as an application/service. What does this imply? For OpenVZ you can expect that when you create containers, its sort of like making Virtual Servers. OpenVZ has interfaces focussed on setting up VPS containers that you decorate yourself manually. Therefore they provide templates for empty linux machines that you can start up and shut down, that you afterward SSH into, to set them up yourself with whatever you need, like a LAMP stack. When you would want to set up a LAMP stack, you would do it like you usually do when you set up a new server. You get an empty linux machine with a virtual ethernet adapter that has its own publicly accessible WAN IP with Ubuntu on it, access it with SSH, and you install all required services in it using your average package manager (yum or apt) and do the setup required in config files yourself. For Docker, you can expect that when you create containers, the container is a single application, that just does ONE thing. Hence, it might need some other containers to help it. (For example a container that provides a database) Docker made it very easy to define whats inside a container without having to actually start one up, and constantly create new exactly equals instances of this container. They define the contents of a docker container (the image) by using very lightweight templates that they call Dockerfiles. There is a huge set of dockerfiles already out there, that you can find in the Docker hub, take a look yourself (its like being in a candy shop with free candy! :D): docker hub. The images produced by these dockerfiles can be pulled with the docker CLI tool, by using a pull command. In docker theres also easy access to stuff like port forwarding, virtual directories (so that you can acces files on the host machine easily) and things alike that any executable could use. The perspective on containers is very different between the 2. In short OpenVZ sees a container as a VPS, and docker sees a container as an application/service. What does this imply? For OpenVZ you can expect that when you create containers, its sort of like making Virtual Servers. OpenVZ has interfaces focussed on setting up VPS containers that you decorate yourself manually. Therefore they provide templates for empty linux machines that you can start up and shut down, that you afterward SSH into, to set them up yourself with whatever you need, like a LAMP stack. When you would want to set up a LAMP stack, you would do it like you usually do when you set up a new server. You get an empty linux machine with a virtual ethernet adapter that has its own publicly accessible WAN IP with Ubuntu on it, access it with SSH, and you install all required services in it using your average package manager (yum or apt) and do the setup required in config files yourself. For Docker, you can expect that when you create containers, the container is a single application, that just does ONE thing. Hence, it might need some other containers to help it. (For example a container that provides a database) Docker made it very easy to define whats inside a container without having to actually start one up, and constantly create new exactly equals instances of this container. They define the contents of a docker container (the image) by using very lightweight templates that they call Dockerfiles. There is a huge set of dockerfiles already out there, that you can find in the Docker hub, take a look yourself (its like being in a candy shop with free candy! :D): docker hub. The images produced by these dockerfiles can be pulled with the docker CLI tool, by using a pull command. In docker theres also easy access to stuff like port forwarding, virtual directories (so that you can acces files on the host machine easily) and things alike that any executable could use. If you would want a LAMP stack in docker, all you do is “docker run -d -p 80:80 tutum/lamp” This pulls the image tutum/lamp, and runs daemonised (-d) it with port 80 from the container forwarded to the port 80 of the host, exposing the inner webservice to the outside. As you can see, it does not have its own IP address in contrast to an OpenVZ machine. And its just like its an apache server running on your root machine. The advantage compared to installing it natively, is that docker makes the installation a lot easier and unlimitedly replicable. Also it doesn’t clutter your host machine with lots of files, and supplies a security boundary around your application. 注：openVZ 是实现vps的一种虚拟技术，所以这里直接拿它来做比较。 简译: 两者在对容器的解读上有很大的不同。 简而言之，openVZ 它是把容器作为vps，而docker 把容器作为应用程序服务。 OpenVZ 它就是一个linux服务器，你可以和操作独立服务器一样，ssh登陆，安装软件包，比如LAMP。 它带有虚拟以太网适配器，可以有自己的独立ip. Docker 它是单个应用程序，只做一件事，就像是服务器上运行的apache 没有自己的独立ip 优势就是它有docker hub，安装容易并且可以无限复制]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作交接事项]]></title>
    <url>%2F2018%2F05%2F17%2Fhandover%2F</url>
    <content type="text"><![CDATA[公司资源三方平台 微信开放平台 (360停车应用) ​ https://open.weixin.qq.com/ ​ 账号：zhanghl@realer.com.cn 短信应用平台 （容联云） https://www.yuntongxun.com 账号：zhanhl@realer.com.cn 微信商户平台 https://pay.weixin.qq.com 云平台 新锐服务器 地区 IP 账号，密码 已运行服务 系统 备注 华南 120.76.78.105(公)10.45.190.12(内) sguap服务，国网统计服务,国网数据库 Centos leifang151@163.com（阿里云） 华北 115.28.211.136(公)10.31.63.198(内) CRM,POSSERVER,CRM调度任务，自由购价格解析，对应华联数据库 Centos leifang151@163.com（阿里云） 华北 120.27.11.151(公)172.31.7.23(私有) jenkins Ubuntu maxwell_lei@qq.com（阿里云） 华北 114.215.96.169(公)10.129.53.147(内) readmine,svn,ftp Ubuntu maxwell_lei@qq.com（阿里云） 华北 114.215.124.247(公)10.30.106.29(内) 360停车，萌优集，易谱，微销 Ubuntu maxwell_lei@qq.com（阿里云） 华南 119.23.153.26(公)10.30.1.122(内) 萌优集POS，POSSERVER Windows maxwell_lei@qq.com（阿里云） 华北 rds23b26q9m4o2k59ng0 360停车数据库 maxwell_lei@qq.com（阿里云） 明思服务器： 地区 IP 账号，密码 已运行服务 系统 备注 北京 123.206.20.141（公）10.141.171.173（内） 自由购 Centos 837132086@qq.com（腾讯云） 北京 118.89.243.154(公)10.141.89.92(内) 支付服务1 Centos 837132086@qq.com（腾讯云） 北京 118.89.235.79(公)10.141.102.185(私有) 支付服务2 Centos 837132086@qq.com（腾讯云） 北京 114.215.96.169(VIP) 支付负载 837132086@qq.com（腾讯云） 北京 10.66.201.228:3306 支付数据库 837132086@qq.com（腾讯云） 宁夏 222.75.145.212 彩票业务，调度业务 Centos 北京 115.28.174.124（公） 支付测试服务，自由购调度任务，vss公众号，打卡统计服务 Centos huasty@aliyun.com（阿里云） 北京 47.95.210.68（公）172.17.200.165（私） 支付备份服务器 Centos huasty@aliyun.com（阿里云） 华联服务器 地区 IP 账号密码 已运行服务 系统 备注 北京 10.4.16.182 CRM服务 Centos 北京 10.4.16.183 CRM服务 Centos 北京 10.4.16.185 综超微信公众号 Centos 北京 10.4.96.100 高超微信公众号 Centos 北京 10.4.16.184 CRM测试服务器 Centos 北京 10.4.16.186 CRM调度作业 Centos 北京 10.4.17.150 BHG自助数据库、BHG自助调度任务 Centos 北京 10.4.17.151 BHG自助 Centos 支付服务明付平台是我司研发的聚合支付平台，目前已支持微信，支付宝，京东，翼支付，银联。 服务架构支付sdk 服务支付调度（报表）服务代码结构 基础工具库 thirdpay_common: 基础 业务层 thirdpay_service,thirdpay_service_iml: 平台业务层 thirdpay_platform_service: 平台业务和三方业务api网关 三方业务 thirdpay_service_ALI: 支付宝支付 thirdpay_service_HWallet:华联钱包（已废弃） thirdpay_service_WX: 微信支付 thirdpay_service_UnionPay: 银联支付 thirdpay_service_JD: 京东 thirdpay_service_YZF: 翼支付 thirdpay_service_mobile:移动和包 控制层 thirdpay_web 部署架构接口文档 刷卡付：http://yuhengzhang.cn/2018/05/09/%E5%88%B7%E5%8D%A1%E6%94%AF%E4%BB%98/ 公众号支付： http://yuhengzhang.cn/2018/05/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98/ 动态码支付：http://yuhengzhang.cn/2018/05/09/%E5%8A%A8%E6%80%81%E7%A0%81%E6%94%AF%E4%BB%98/ 一码付： 小程序支付： 未来规划及待优化项 支付通道配置(明付，亚博松，铁路) 2018-05-22 支付宝清算报表支持，目前是明思负责 扫码枪配置及加解密 清算报表性能优化，协助明思处理 调度任务之备份订单表 银联支付开发已完成，待完成调试上线 移动和包开发基本已完成，待完成调试上线 翼支付开发已完成，待完成调试上线 华联公众号cms服务bhg-cms服务是为华联提供的，集公众号营销，电子会员，o2o活动于一体的内容服务平台。 服务架构代码结构部署架构三期任务表下载地址：http://p8kn4m8eo.bkt.clouddn.com/%E5%8C%97%E4%BA%AC%E5%8D%8E%E8%81%94%E7%BB%BC%E8%B6%85%E5%BE%85%E5%BC%80%E5%8F%91%E5%BC%80%E5%8F%91%E8%AF%84%E4%BC%B020180517.xlsx 序号 系统 事项 现状 需求 优先级 明思回复 开发/测试工时（人/日） 1 微信公众号 微信素材分地区，标题更新有反复，请核查 全国共享所有素材，所有人都可以删除任意地区任意素材，非常混乱，也非常危险 1、素材分地区管理； 2、解决素材保存数量上限问题，是否有补救办法 越快越好 分地区管理：最多 实现上次沟通的方案。素材上限问题没有办法，微信限制。 4 2 微信推送增加次数提醒功能 提示比较简单 建议增加推送剩余次数的提醒，并且加强发送流程的确认，增强仪式感 越快越好 新版本已有确认功能。推送次数提醒暂时没有。 3 3 地区微信粉丝转移至全国号 尚未迁移 1、请信息部支持全国粉丝迁移工作； 2、全国号是否支持各地区同时迁移？ 3、迁移过程中是否对全国号的使用有影响？ 4、迁移后的粉丝定位、分地区问题。 越快越好 1,2.可以用脚本一次性处理掉。 3.不会 4.没有定位，分地区。只能是该用户使用全国开启定位时，再补处理 每个地区1.5人天 4 华东区旧账号电子会员迁移 这一部分会员没有所属门店 1、是否可迁移至全国号？ 2、华东区是否可将综超、高超微信分开？微信后台需删除华东全部高超门店。 越快越好 基本同上 5 电子优惠券添加提醒功能（最着急） 无提醒功能 1、收到卡券时提示领取成功； 2、卡券即将到期时给予提示； 2018年5月31日 4 6 微信图文插入外网链接功能 只能插入已推送过的图文素材，本功能运用于微信栏目推广 建议研究可行性并开发 2018年5月31日 待确认，目前调研微信不能实现 7 注册电子会员自动送电子优惠券or积分 （着急） 无 分地区管理 2018年6月1日 15 8 扫描二维码领取电子优惠券 （着急） 无 分地区管理 2018年6月1日 5 9 会员线上游戏（如大转盘、老虎机、摇一摇等） 无 1、分地区管理； 2、通过扫描二维码进入游戏，二维码可选择公开or非公开； 3、可后台设置中奖率、参与次数； 4、可后台设置是否消减积分参与 2018年6月30日 根据游戏确定，待确认 10 会员课堂 - 1、增加门店勾选功能； 2、手机页面，活动标题下方显示日期； 3、”活动门店“改为”选择活动门店“； 4、”活动时间“下面，将具体时间显示调整为可选择性呈现； 5、”活动地址“改为”客服电话“； 6、”报名“改为”我要报名”； 7、会员在选择门店的同时，增加选择日期的选项； 8、已报名成功的会员手机页面显示“已报名”; 越快越好 已经完成。测试中 11 海报批量上传，海报页面加载太慢问题 单张上传 是否可添加“批量上传”及“图片排序”功能 - 2 12 微信栏目编辑按照地区划分 按照城市划分 举例：贵阳地区海报、热销榜单、自有品牌等模块需要分贵阳、毕节、安顺三个城市分别上传，是否可实现同一地区管理不同城市门店，但录入的商品可共享 - 除了海报。其余已是这样。海报这个已处理 2 13 微信栏目转发时的概述、缩略图 转发时只显示公众号名称和网址 建议按照微信文章转发时的效果开发处理 14 微信分地区推送增加后台的数据统计功能 无 增加针对已推送信息的“图文分析”功能，可支持分地区分析； POS款台 UI界面支持触屏操作。 触摸大屏，界面样式布局及菜单按钮布局设计。 13 POS款台按设计程序修改 14 一体秤自带热敏打印机，客显，刷卡器等外设驱动支持。 1.打印机集成开发，打印模式不改变 2.客显集成开发 3.刷卡器集成开发 4.一体化电子秤集成 15 钱箱设备可选配置支持。 钱箱集成开发 16 CRM 为报表系统提供数据 为报表系统提供增量数据，需在部分表中增加修改时间字段，修改部分视图 2]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web服务一些概念理解]]></title>
    <url>%2F2018%2F05%2F17%2Fserver%2F</url>
    <content type="text"><![CDATA[关于服务器服务器种类介绍 独立服务器 机房里实实在在的物理服务器，也可以理解为高配版的pc机。 vps (虚拟专用服务器） 独立服务器通过虚拟化技术虚拟出多个专用服务器。 云服务ECS(Elastic Compute Service) 建立在服务器集群之上的，可以理解为，也是通过虚拟化技术整合多台独立服务器资源的弹性服务器。 虚拟主机 一个独立主机或者vps服务器上，可以运行多个站点的技术。通俗的理解: 云服务可以看作是大酒店，独立服务器可以认为是酒店的房间，vps 理解为房间的卧室，虚拟主机理解为卧室里一个床位。 你买了一个云服务，相当于你定了一个房间(这里只是比喻，这里并不一定是独立服务器），不够用随时加订，每一间卧室（vps)都可以睡觉，看电视，拉便便，但是虚拟主机就只能让你睡觉（部署站点用）。 服务器应用场景介绍 独立服务器 就是想要有自己的机房（比如大厂，企事业单位等） 服务器租赁提供商 虚拟主机 企业网站，个人博客(可参照阿里云理解https://wanwang.aliyun.com/hosting) vps 适用于小型Web应用、轻量应用等低负载、突发型应用场景(可参照理解https://www.aliyun.com/product/swas 阿里云已提供系统镜像，应用镜像两种) 云服务(弹性服务) 企业应用，视频编码等高耗cpu负载的场景 关于apache http server, tomcat, nginx严格来说，apache http server/nginx 应该叫做HTTP Server(当然nginx可以作为邮件服务，Tcp服务适用）,tomcat 是AppServer，他们都可以： 运行在上面说的服务器上，通过绑定服务器的ip地址，并监听某个tcp端口来接受并处理http请求。 通过配置，生成多个虚拟主机 他们不同在于： apache http server/nginx 可以做代理，负载均衡，处理静态资源(就是不同客户端看到的东西是一样的)。 tomcat 可以处理动态资源（就是不同客户端看到的东西是不一样的）。 所以一般tomcat 是和nginx配合使用的： 动静资源分离，通过nginx反向代理功能，分发请求，动态资源交给tomcat,而静态资源直接邮nginx返回，这样大大减轻tomcat压力。 负载均衡，业务压力增大时，一个tomcat 不足以处理时，可以启动多个tomcat实例进行水平扩展,而nginx的负载均衡功能可以把请求分发到不同的tomcat实例上。 以上web server都能作为虚拟主机配置使用，具体虚拟主机的配置策略有以下几种： 基于ip 把下面基于域名的配置的地方改为对应ip就可以，如果您的网站有强烈seo需求，可以配置独立外网ip。 基于域名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&gt; &lt;!-- 360停车--&gt;&gt; &gt; &lt;Host name="www.360park.com.cn" appBase="webapps/360park"&gt; &gt; unpackWARs="true" autoDeploy="true"&gt;&gt; &gt; &lt;!-- SingleSignOn valve, share authentication between web applications&gt; &gt; Documentation at: /docs/config/valve.html --&gt;&gt; &gt; &lt;!--&gt; &gt; &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;&gt; &gt; --&gt;&gt; &gt; &lt;Context path="" docBase="/rs/tomcat_web/webapps/360park" debug="0" reloadable="true" /&gt;&gt; &gt; &lt;!-- Access log processes all example.&gt; &gt; Documentation at: /docs/config/valve.html&gt; &gt; Note: The pattern used is equivalent to using pattern="common" --&gt;&gt; &gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"&gt; &gt; prefix="localhost_access_log." suffix=".txt"&gt; &gt; pattern="%h %l %u %t %r %s %b" /&gt;&gt; &gt; &lt;/Host&gt;&gt; &gt; &lt;!-- 新锐友信--&gt;&gt; &gt; &lt;Host name="www.realer.cn" appBase="webapps/tonghang"&gt; &gt; unpackWARs="true" autoDeploy="true"&gt;&gt; &gt; &lt;Alias&gt;realer.cn&lt;/Alias&gt;&gt; &gt; &lt;Alias&gt;www.realer.cn&lt;/Alias&gt;&gt; &gt; &lt;!-- SingleSignOn valve, share authentication between web applications&gt; &gt; Documentation at: /docs/config/valve.html --&gt;&gt; &gt; &lt;!--&gt; &gt; &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;&gt; &gt; --&gt;&gt; &gt; &lt;Context path="" docBase="/rs/tomcat_web/webapps/tonghang" debug="0" reloadable="true" /&gt;&gt; &gt; &lt;!-- Access log processes all example.&gt; &gt; Documentation at: /docs/config/valve.html&gt; &gt; Note: The pattern used is equivalent to using pattern="common" --&gt;&gt; &gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"&gt; &gt; prefix="localhost_access_log." suffix=".txt"&gt; &gt; pattern="%h %l %u %t %r %s %b" /&gt;&gt; &gt; &lt;/Host&gt;&gt; &gt; &gt; &gt; 基于端口 12345678910111213141516171819202122232425&gt; &lt;Service name="myService1" &gt;&gt; &lt;Connector port="9081"/&gt;&gt; &lt;Engine name="myEngine1" defaultHost="test1" &gt;&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt;&gt; &lt;Host name="test1" appBase="webapps1" /&gt;&gt; &lt;/Engine&gt;&gt; &lt;/Service&gt;&gt; &gt; &gt; &lt;Service name="myService2" &gt;&gt; &lt;Connector port="9082"/&gt;&gt; &lt;Engine name="myEngine2" defaultHost="test2" &gt;&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt;&gt; &lt;Host name="test2" appBase="webapps2" /&gt;&gt; &lt;/Engine&gt;&gt; &lt;/Service&gt;&gt; &gt; &lt;Service name="myService3" &gt;&gt; &lt;Connector port="9083"/&gt;&gt; &lt;Engine name="myEngine3" defaultHost="test3" &gt;&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt;&gt; &lt;Host name="test3" appBase="webapps3" /&gt;&gt; &lt;/Engine&gt;&gt; &lt;/Service&gt;&gt; 具体另外两个配置可自行百度，差不多，以上提供tomcat配置指南，实际中如果是静态网页的官网需求，最好是用nginx。 正向代理 和 反向代理 你想访问被墙掉的谷歌，你可以买一个vpn。这个vpn是你买的，是代理你去向谷歌发起请求的。 你想访问百度，会有一个转发，到百度内网，对于你来说你不知道，也不关心，它是代理百度内部的服务。 所以正向代理和反向代理的说法是相对的,但是通常描述都是以客户端为对照方（即发起请求方） 关于高并发负载均衡做什么用的呢？其实可以按照动词的方式理解，反过来均衡负载，就是你的业务负载高的时候，通过一些技术手段均衡你的业务负载，解决高并发问题，高并发瓶颈一般在应用服务和数据库服务上。 应用服务负载均衡？ 硬负载 F5 Array 软负载 dns dns负载均衡是通过DNS服务器实现的，主要用于把请求均匀的分布到nginx服务器上。其实真是情况中可能是用来根据地域区分请求。但是一个地域中的请求还算需要均匀的分配到nginx服务器上的。 有两个缺点：一个是无法区分服务是否挂掉，即时某个NGINX服务器挂掉了，DNS仍然会分配。另一个是DNS缓存的问题，用户访问网站，网站域名被DNS服务器解析为某个IP。这个IP一般情况都会在客户端本地进行缓存，短时间内下次再访问这个域名，会直接从缓存中拿，无法达到真正的均匀，但这对服务器影响不算太大。重要的请求个数无法真正的做到均衡，比如每个Nginx服务器拿到100个请求，但是所有的耗时大请求都集中到某一台服务器中，那么这个服务器压力将会很大。其他的会比较空闲。 lvs 基于网络七层协议第四层，针对高可伸缩、高可用网络服务的需求，我们给出了基于IP层和基于内容请求分发的负载平衡调度解决方法，并在Linux内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟服务器。 nginx 基于网络七层协议上第七层（应用层），配置简单，nginx是目前流行的，优秀的反向代理服务器（其实他不仅仅是反向代理服务器，还是web服务器，也可以是邮件代理服务器，感谢俄罗斯人的智慧）。nginx作为反向代理服务器，主要负责把请求均匀的分摊到应用服务器中。为了达到均匀，Nginx有五种负载均衡策略。 轮询 请求依次轮流往每个应用服务器上进行分配，分配策略比较简单。缺点：不均匀，可能会出现，某些服务器接受的请求较重，负载压力重，有些负荷小，不可控。另外服务器之间需要进行session同步。 权重轮询 在轮询的基础上给每个应用服务器一定的权重，比如三台服务器，权重设置为 0.4:0.4:0.2。来到10个请求（序号1到10），那么根据轮询以及权重，序号1、4、 6、 9的请求会打到 第一台服务器上，序号 2、 5 、7 、10 的请求会打到第二台服务器上，剩余序号3 、 8的 请求打到第三台服务器上。优点：可以根据情况进行调整。可控，仍然需要进行session同步。 IP-hash 优点：无需进行session同步，固定IP会固定访问一台服务器。缺点：恶意攻击，会造成某台服务器压垮。提供的服务不同，面向的地区不同，IP可能会出现集中，造成不均匀，不可控。 fair 这种相当于自适应，会根据服务器处理请求的速度进行负载均衡分配。处理请求最早结束的，拿到下一个请求。看上去是不是很好。但是一般都不使用，说是考虑到网络不稳定因素。还有待研究。这种也需要进行session同步。 URL-hash 这种是根据URL进行hash，这样某些请求永远打某台服务器。利于利用服务器的缓存，但是可能由于URL的哈希值分布不均匀，以及业务侧重造成某些服务器压力大，某些负荷低。这种也需要进行session同步。 目前比较流行的配置是使用第二种进行配置，但是实际生产中还是需要根据业务特点进行配置，每种策略都具有每种策略的优缺点。 haproxy 数据库负载均衡? 读写分离 spring应用层解决方案，配置多个数据源 中间件 mysql-proxy :https://downloads.mysql.com/archives/proxy/ Amoeba for MySQL:http://docs.hexnova.com/amoeba/ 分库分表 spring应用层解决方案，http://shardingjdbc.io/ 中间件 mycat:http://www.mycat.io/ 关于高可用 高可用： 负载均衡主备 nginx+keepalived 参考配置https://www.jianshu.com/p/b147a719f740 lvs+keepalived (图转) 数据库主备 关于高性能高性能： http缓存服务器：squid/varnish/nginx cache ,按osi,应该属于应用层 存储缓存服务器: redis/memcached，按osi,属于存储阵营，应该属于表示层 所以一般的服务器部署架构可以这样 F5/LVS(keepalived)&lt;—&gt;Haproxy/nginx&lt;—&gt;Squid/Varnish&lt;—&gt;AppServer&lt;—&gt;redis/memcached&lt;—&gt;db。 关于压测 AB jemeter loadrunner httpload 三方云测试平台 关于童鞋提出的两疑问点？vps, vm, docker 区别？请参照 http://yuhengzhang.cn/2018/05/18/docker_1/ http://yuhengzhang.cn/2018/05/17/docker/]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker vs vm]]></title>
    <url>%2F2018%2F05%2F17%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker vs VM 注: 关于docker 里，宿主os和容器os必须相同，这点是错误的。宿主os和容器os是可以不同的，但是 ​ 目前容器os只能是linux。作者这里描述不同，是因为没考虑windows上跑docker.应为windows 上 ​ 跑docker，其实底下跑了linux vm的。 ​ docker 引擎的基础是linux自带的容器（lxc)技术，容器的应用是在它们自己的空间上共享宿主内核。这也是为 什么容器os只能是linux原因]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2018%2F05%2F13%2Fresume%2F</url>
    <content type="text"><![CDATA[联系方式 手机：13263369194 邮箱：hailianglone@gmail.com,hailianglone@126.com QQ: 317824594 简历线上版：http://yuhengzhang.cn/2018/05/13/resume，密钥：zhanghl 个人信息 张海亮／男／1986 本科／河北大学（数学与计算机系） 工作年限： 8.5年 工作经历：1年J2ME方向，4年Android方向，3.5年Java后端 技术博客： http://yuhengzhang.cn (很汗颜，刚搭建) 期望职位 : Java 后台高级工程师 期望薪资：面议 期望城市：北京 工作经历北京新锐友信软件技术有限公司（2013年5月～至今）职位：技术合伙人 产品聚合支付（明付平台）明付平台是集支付宝，微信，京东，翼支付，银联二维码等平台之上的三方支付服务商平台，旨在帮助企业迅速便捷的接入相关支付的开放平台，目前仅对华联，柏尤商贸，萌优集内部开放使用，日流水700w,日订单15w单. 项目架构：spring ＋ springMvc ＋ mybatis-plus + swagger-ui ＋ vue(app,admin) 部署架构：腾讯云，lvs(负载均衡) ＋ nginx(反向代理） ＋ tomcat(AppServer,2节点) ＋ redis(缓存服务器) ＋ mysql(读写分离) 代码架构：maven多模块管理，每种支付封装为sdk，作为子module接入，方便新的支付方式介入，对客户端统一提供api网关（app,pos,h5),平台层提供支付路由管理，redis保证同一笔交易幂等，订单号采用snowflake算法，保证分布式订单号唯一，前后端分离。 安全处理：api 统一https，并给商户分配api-key,作为参数加签，商户信息，持久化统一aes加密，敏感配置文件统一aes加密. 目前是分支付平台服务和调度作业服务（xxl-job 基础上修改的轻量的分布式作业调度系统） 后面计划，对于订单表水平切分，目前暂定方案pingCap团队的TiDB, redis 进行高可用处理，防止单点故障 小咖停车小咖停车是基于简单IOT蓝牙通信技术，通过App和智能地锁的配合，方便业主操作，提供错时租赁功能，并提供线上小咖钱包，微信，支付宝支付，以及收入提现功能，，用来解决停车难的问题， 下载链接：http://www.360park.com.cn 项目架构：spring+springMvc+jpa+j2cache+jsp 部署架构：用户量小，目前是都是单点，tomcat+redis+mysql Android客户端：volley+greendao+ble4.0+jpush 零钱彩零钱彩是彩票和零售的一种结合创新，目前已在华联部分超市试运营，由于本产品主属兄弟公司，业务和模式上暂处保密，目前该产品已获PreA融资。 项目架构: spring+springMvc+mybatis-plus+swagger-ui+vue 部署架构：福彩专线，nginx/keepalive(负载均衡和反向代理,keepalive保证高可用)＋tomcat+redis+mysql 代码架构：同支付平台类似，各省福彩平台封装的sdk，作为子module,方便接入新省。 零钱彩要对上游彩票拆单，缓存池处理，给下游零钱购彩使用，用信号量semaphore做资源池，同时用显示锁ReentrantLock做分段锁对资源池进行管理保证高并发，资源池补仓支持加载因子判断主动补仓和调度作业被动补仓两种方式保证高可用。目前还没有做资源池服务的高可用。 小程序版： 项目北京华联CRM系统北京华联crm系统是针对华联信息系统整个闭环系统中关于会员系统的解决方案，零售行业的会员系统是所有crm系统中最为复杂的，已实现主要功能列表如下： 组织机构和门店管理 员工管理，菜单管理和角色权限管理 基础设置（俱乐部设置，积分权益设置，销售权益设置，支付权益设置） 积分返利，积分抵现，积分返礼 促销管理（折扣促销，优惠券促销，积分促销） 会员卡服务台 办卡自动化处理 简单审批 报表系统 架构基本同上，数据库oracle, rac保证高可用，这部分基本由华联dba维护，促销管理采用装饰器模式，方便促销计算和促销扩展。 北京华联公众号系统华联公众号系统是华联为了集中管理各个地区公众号营销以及电子会员管理而定制的公众号系统开发，系统功能列表： 粉丝自动划分地区 分地区设置海报，本地特色，热销榜单，自由品牌，每月上新 电子会员 会员课堂 BHG服务（电子发票，会员权益，附近门店，意见反馈，常见问题） 分地区招聘设置 需要针对用户定位，自动划分门店。 国安盒子触控遥控器(android)本系统是另一个初创团队的项目，一期主要本人负责和带队，遥控器广州地区一小批量量产，该遥控器是基于android原生系统定制，不同于目前市场上的智能遥控器，触控遥控器的本质是反向了小屏投大屏的模式，它是把电视屏幕投到遥控器屏幕附带红外控制功能，投屏模式分为镜像同屏和重绘同屏模式，系统架构为了后来要做平台的需求，架构设计如下： 其它项目 优驾行（陕西优驾行）(android) 掌中宝 （圣元国际）（web and android) 国网直升机调度系统（国家电网）（web) 烤圈（海尔）（android) 黄金60s（外包，湖南卫视）（android) 宝宝讲故事（外包，金和）（android) 微视（外包，cctv)（android) 中科创达科技股份有限公司（2011年9月～2013年5月）职位：subleader 展讯8810，6810等项目（Android整体解决方案）本人主要担任Android app小组subleader,团队4～6人，主负责模块： Contacts （联系人） Launcher（主界面） LockScreen （锁屏） Setting （设置） QuickSearchBox（搜索） InputMethod（输入法） 北京捷通华声（2009年9月～2011年9月）职位：研发工程师 天行输入法主打手写输入，支持全屏手写，窗口书写，字体支持颜色设置，大小设置，简繁体设置以及毛笔等格式设置，以及行识别。 其它项目J2ME 相关，诺基亚N71（塞班系统）等手机上的电子书，小游戏开发。 开源项目和作品短暂参与过iBase4j 的项目，除了提了问题和提供swagger-ui支持，基本没有深度参与。 https://gitee.com/iBase4J/iBase4J 技能清单 java 后端：spring/springmvc/mybatis/hibernate/jpa/mysql/sqlite/redis（熟悉), tidb/oracle （了解） Web前端：jsp（熟悉），jquery/vue/argularjs/react（了解） 版本管理，文档和自动化部署工具：/cvs/svn/git/jenkins/redmine（熟悉），docker（了解） 包管理：/ant/maven/gradle（熟悉）, npm/yarn（前端了解） 单元测试：junit 文件存储：/ftp/fastdfs （熟悉） Linux 常用命令（一直在ubuntu下工作） Web容器：/nginx/tomcat（熟悉），weblogic/jetty （了解）,netty(了解) Android：app/framework 云和开放平台：阿里云/腾讯云/ecs/oss/rds，七牛云，亚马逊云（马上要），/微信支付平台/微信公众平台/微信开放平台/蚂蚁金服开放平台／微博开放平台／腾讯开放平台／科大讯飞语音云／容联云短信／友盟统计／极光推送／环信通信／TestIn测试平台／银联开放平台／京东金融开放平台／电信翼支付开放平台／ 分布式与大数据：dubbo/zookeeper/hadoop/spark/storm等（了解，目前实际项目未用到） 常用传输数据结构：/xml/json/protobuf 致谢感谢您花时间阅读我的简历，期待有机会与您一起共事。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务安全]]></title>
    <url>%2F2018%2F05%2F13%2F%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[安全存储相关 数据库仅支持内网访问 数据库驱动帐号，密码配置文件，通过AES加密处理，使用时动态解密处理 数据库密码复杂度要至少包含大小写字母，特殊符号及数字，8位以上 数据库做读写分离，针对读库和写库分别配置不同的权限帐号 数据库管理员帐号，密码只对DBA负责人开放 数据库敏感信息，如用户手机号，商户信息等持久化和反序列化采用AES等相关加密算法进行处理 数据库性能指标TPS,要根据相关业务和用户使用量，进行设计和规划基准测试，比如用sysbench分别进行cpu的基准测试和i/o的基准测试，有条件的话，可以拿dump生产环境进行压力测试 数据库sql语句使用要避免可以进行sql注入攻击的拼写方法 数据库关键信息，要分别支持冷备和热备 应用服务和负载均衡 Https支持 如果是平台接入，iptables要设置访问白名单 应用服务部署单独分配部署帐号，不采用root用户 核心应用服务尽量和其他应用服务分离 请求和返回进行加签和验签处理 某些业务请求要保证幂等性（分布式锁，或者数据库支持等） 后台应用服务，进行严格权限管理 防止频繁相同请求恶意攻击（例如，可以简单的过滤器实现） 后台管理页面要防止js注入，中间人劫持等攻击 进行模拟ddos攻击测试 应用日志要严格控制敏感信息和日志等级处理 其他 保证高可用，无论存储服务，应用服务，负载分发服务一定要保证多节点部署 保证高并发，无论存储服务，应用服务，负载分发服务一定要保证容易水平扩展 保证网络稳定性，做好多运营商节点部署功能 支持热部署，及灰度发布]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2018%2F05%2F13%2Fkownledge%2F</url>
    <content type="text"><![CDATA[mac 拼音选择框不见？打开 Terminal （命令行），输入下面，回车即可。 1pkill -f SCIM.app Linux 下Tomcat deploy 阻塞在INFO: Deploying web application directory ….?linux 或者部分unix系统提供随机数设备是/dev/random和/dev/urandom，两个区别是，random安全性高， 生成随机数时间间隔有点长，jdk默认random. 修改$JAVA_HOME/jre/lib/security/java.security文件，替换securerandom.source=file:/dev/random/为secureradom.source=file:/dev/./urandom]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建全教程（一）]]></title>
    <url>%2F2018%2F05%2F10%2Fhexo_1%2F</url>
    <content type="text"><![CDATA[引言 心血来潮，搭建个博客玩玩，看了网上很多教程，有些很全面，我也是参照大家的基本一气呵成，呈现给大家现在的这个样子，但是迫于好奇心，总想知道那些奇奇怪怪的命令到底是什么？于是有了本系列教程的第一部分。 术语 hexo: 基于nodejs的博客框架 next: hexo 主题 github: 不解释 nodejs: javascript运行环境]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号支付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[公众号支付公众号支付，是渠道商通过微信公众号中的页面发起的线上支付场景渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【下单】接口，取得对应公众号发起支付的参数列表 接入商调起支付接口，根据支付返回码确认支付状态，如果异常情况下，请调用查询接口确认支付状态 如果接入商有退款需求，可根据平台订单号进行【退款】操作 注意 暂时不支持支付通知处理 下单生成公众号支付参数接口 接口地址： 沙箱：https://realer.cn/api/payService/{version}/unifiedOrder 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 用户ID openId 否 String oG3werwerwer1221 动态码请忽略 接入商订单号 orderNo 否 String 1290012 接入商不传，默认平台订单号 订单金额 amount 是 int 12 单位（分） 订单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss 支付类型 payType 是 String WX_NATIVE WX_PUBLIC IP地址 ip 是 String 127.0.0.1 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 应用ID appId 否 String wxd678efh567hg6787 时间戳 timeStamp 否 String 20180504123546 随机串 nonceStr 否 String wxd678efh567hg6787fsdfsd2 随机串 数据包 package 否 String prepay_id=wx2017033010242291fcfe0db70013231072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx2017033010242291fcfe0db70013231072 签名方式 signType 否 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 签名 paySign 否 String oG3werwerwer1221 明付平台订单号 tradeNo 是 String P98212781821288121 第三方平台订单 outTradeNo 否 String 4001220181230456245 二维码URL codeUrl 是 String weixin://123.12121 动态码关注字段 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>动态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷卡付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%88%B7%E5%8D%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[刷卡支付刷卡支付，是接入渠道商通过pos款台，扫用户支付码的支付场景渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【设备接入】接口，取得对应支付授权码 接入商调用明付平台 【授权码支付】接口，进行支付 如果接入商有退款需求，可根据平台订单号进行【退款】操作 设备接入 接口地址： 沙箱：https://realer.cn/api/payService/{version}/device/checkIn 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 授权码 licenceNo 是 String 4ef234239ioiwejq 刷卡支付接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/userPayCode version 1.0 : 同步请求方式 version 2.0 : 异步请求方式，需要客户端主动发起轮询 参数列表 字段名 变量名 必填 类型 示例值 描述 授权码 serierNo 是 String 4ef234239ioiwejq 支付授权码 token 是 String 扫码所得 金额 amount 是 int 10 单位（分） 订单号 orderNo 是 String 接入商订单号 订单时间 beginTime 是 String 20180509123456 yyyyMMddHHmmss 支付类型 payType 是 String WX_F2F,ALI_F2F,JD_F2F ip ip 是 String 127.0.0.1 收银员编号 cashierNo 是 String 80 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 是 String 签名 sign 是 String 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>刷卡付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态码支付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8A%A8%E6%80%81%E7%A0%81%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[动态码支付动态码支付，是渠道商根据用户订单生成对应支付二维码，用户打开支付宝或者微信扫一扫功能，进行扫码支付。渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【下单】接口，取得对应支付二维码链接和对应平台订单号 接入商同时发起轮询【查询】接口，轮询间隔3~5,轮询5次，如果仍然没有收到支付确认，请重新【下单】刷新二维码，并提示用户重新扫码支付 如果接入商有退款需求，可根据平台订单号进行【退款】操作 注意 暂时不支持支付通知处理 下单生成二维码接口 接口地址： 沙箱：https://realer.cn/api/payService/{version}/unifiedOrder 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 用户ID openId 否 String oG3werwerwer1221 动态码请忽略 接入商订单号 orderNo 否 String 1290012 接入商不传，默认平台订单号 订单金额 amount 是 int 12 单位（分） 订单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss 支付类型 payType 是 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 应用ID appId 否 String wxd678efh567hg6787 时间戳 timeStamp 否 String 20180504123546 随机串 nonceStr 否 String wxd678efh567hg6787fsdfsd2 随机串 数据包 package 否 String prepay_id=wx2017033010242291fcfe0db70013231072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx2017033010242291fcfe0db70013231072 签名方式 signType 否 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 签名 paySign 否 String oG3werwerwer1221 明付平台订单号 tradeNo 是 String P98212781821288121 第三方平台订单 outTradeNo 否 String 4001220181230456245 二维码URL codeUrl 是 String weixin://123.12121 动态码关注字段 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>动态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URemoteSdk 开发文档]]></title>
    <url>%2F2017%2F05%2F09%2Furemote%2F</url>
    <content type="text"><![CDATA[目录1 文档说明功能描述URemote是盛世辉科技有限公司自主研发的一套用于智能遥控终端和电视盒子进行实时通信的整体解决方案，URemote核心部分即URemoteService将在本文档中做详细说明，对于三方app厂商，URemote 是作为开放平台以URemoteSdk的方式，提供给其进行即成，二次开发。URemoteSdk介绍详见： URemoteSdk接口文档_V1.0.doc 阅读对象本文档面向盛世辉内部研发经理，研发工程师。该人员需要具备一定的Android开发能力，只允许在公司内部流转。 术语 名词 解释 URemoteSdk APP层和URemoteService交互API,URemoteSdk会针对遥控器和盒子两端分别给出API接入说明，下文中如无特殊说明，C_URemoteSdk代指遥控端接入API，S_URemoteSdk代值盒子端接入API URemoteService 开发人员只需了解该服务在整个框架中得位置及意义，同理，如无特殊说明，C_URemoteService代指遥控端服务，S_URemoteService代指盒子端服务 请求 通过AIDL/PROTOBUF协议把数据发送给接收方的过程。 通知 一般指盒子端主动推送给遥控器端得消息类型，比如当前处于什么模式（重绘，镜像，还是异步） 返回 遥控端发送操控指令给盒子有两种接入模式，同步或者异步，具体下文会具体描述 心跳 开发人员只做了解，具体代值遥控和盒子通讯机制 URemote整体架构及URemoteService系统架构及历史演进： 以上架构图是产品初始设计，可以看到，目前最终实现基本未脱离此结构设计，而实际变动部分会在以下内容中说明缘由，框架中，RemoteService是该架构中的核心部分，向上以sdk的方式，给应用层app提供接入指南，向下以本地库为依赖。 RemoteService：提供重绘服务(EventService)，镜像服务(ScreenService)，以及同屏基础设置， 具体名称以实际代码为准。目前代码实现层面上，RemoteService，只提供了对应服务，没有提供对应的设置页面，之后应该在这方面有所补充，例如，提供镜像参数的设置，服务端口的设置等。 通信原本定义基于TCP的socket形式进行，目前是采用开源工程AndroidAsync，具体请参考： https://github.com/koush/AndroidAsync以websocket形式实现，产品原定义的核心的touch消息，镜像协议，是想以so库的形式，这个可能是我们平台作为产品形式，最后从性能，稳定性等方面最终实现的交互方式（参考资料： https://openstf.io/） 目前产品架构： 图中，镜像部分应该是直接和盒子uremoteservice进行通信，这里没有画出跨层通信的交互。镜像部分具体请徐工补充完整。App层和service通过提供的api进行通信，通信方式aidl. Service之间通过websocket通信，通信协议protobuf。 URemoteServiceURemoteService 中的模块（客户端和服务端基本一样，这里只介绍相对复杂一点的遥控客户端，具体差异请参考源代码） WatchDog watchdog 的实现是基于alarm机制，定时监测服务是否存活，主要实现功能uremoteservice保活，android里保活机制有很多种： 有系统权限，内置rom，可以init启动，自动保活 alarm机制，类似看门狗实现 双service互保 我们版本目前采用第二种，之后可以根据我们产品特点进行调整。 websocket： 采用开源AndroidAsync，具体请参考上文提到的参考链接。重绘端口：6059,镜像端口：6060 protobuf: 具体请参考另一篇关于uremoteSdk的介绍 heartbeat: 心跳包，按照AndroidAsync官网建议，采用tcp ping 机制发送固定心跳字断 coreservice 向上提供aidl接口，水平service通信提供websocket接口路由 http 新增协议，主要提供一些同步查询接口，具体请黄海，志臣在uremoteSdk中补充 设备发现 结构图中，遗漏了设备发现功能，设备发现通过服务器发送组播，客户端扫描发送udp包建立握手，获取盒子IP.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URemoteSdk接口文档]]></title>
    <url>%2F2017%2F05%2F09%2Furemote_1%2F</url>
    <content type="text"><![CDATA[文档修订记录： 日期 版本 说明 作者 2017-05-22 1.0 uremotesdk 接口文档 张海亮 2017-07-03 1.0 增加listener,callback接口说明 张海亮 2017-07-05 1.0 增加播控接口说明 张海亮 1 文档说明1.1 功能描述URemoteSdk 是盛世辉科技有限公司提供得一套针对电视盒子和盛世辉遥控器进行网络自定义指令通信方案。第三方盒子APP通过该sdk得接入，可以很放便的通过遥控器操控盒子，实现一些传统遥控器不可有的一些用户操作体验。 1.2 阅读对象本文档面向电视盒子三方APP开发人员、编程人员及测试人员。该人员需要具备一定的Android开发能力。 1.3 术语 名词 解释 URemoteSdk APP层和URemoteService交互API,URemoteSdk会针对遥控器和盒子两端分别给出API接入说明，下文中如无特殊说明，C_URemoteSdk代指遥控端接入API，S_URemoteSdk代值盒子端接入API URemoteService 开发人员只需了解该服务在整个框架中得位置及意义，同理，如无特殊说明，C_URemoteService代指遥控端服务，S_URemoteService代值盒子端服务 请求 通过AIDL/PROTOBUF协议把数据发送给接收方的过程。 通知 一般指盒子端主动推送给遥控器端得消息类型，比如当前处于什么模式（重绘，镜像，还是异步） 返回 遥控端发送操控指令给盒子有两种接入模式，同步或者异步，具体下文会具体描述 心跳 开发人员只做了解，具体代值遥控和盒子通讯机制 2 应用场景及接入流程系统架构： 2.1 重绘同屏应用场景介绍：适用于盒子三方APP开发商，需要借助盒子定制的盛世辉触控遥控器提高应用或者游戏在盒子上的可操作和便利性得需求。 l 场景：用户选择盛世辉遥控器打开电视盒子进入对应APP后，通过对遥控器的点击，触摸，滑动等操作来控制盒子。 l 系统交互时序图 l 具体流程： 用户打开同屏APP，选择某个页面节点。 用户对该节点进行点击或者滑动等操作，封装为具体通信协议发送给盒子。 盒子收到消息同步或者异步返回，同时自己执行对应指令响应。 盒子响应对应指令，进行页面跳转 遥控器响应回传指令，进行页面跳转。 2.2 镜像同屏略 3 接口规范URemoteSdk两类通讯机制，一是websocket，二是AIDL,通讯协议统一用Protobuf. 上层APP和service交互，即URemoteSdk是AIDL。C_URemoteService与S_URemoteService交互是webSocket. Protobuf接口规范如下： 123456789message Envelope &#123; optional uint32 id = 1; required MessageType type = 2; required bytes message = 3;&#125; 1）id 指令消息id，可选参数，一般用于接口异步返回标识。 2）MessageType 指令消息类型，支持自定义，目前支持消息类型： 系统内置消息 12345678910111213141516171819202122232425262728293031323334353637383940414243enum MessageType &#123; EVENT_KEY = 1; EVENT_TOUCH = 2; NOTIFY_STATE = 3; GET_PROCESS = 4; GET_APP = 5; GET_VERSION = 6; GET_DISPLAY = 7; GET_PROPERTIES = 8; GET_SERVER = 9; EVENT_CLICK = 10; EVENT_PLAYER = 11; EVENT_CHANNEL = 12; NOTIFY_PLAYER = 13; EVENT_HOME = 14; EVENT_MESSAGE = 15; EVENT_DIFF = 16; EVENT_DESTORY = 17; EVENT_VOLUME = 18; EVENT_AD = 19; EVENT_GENSOR = 20;&#125; 自定义消息统一用EVENT_MESSAGE。 3）message 具体消息体 以上定义可参照wire.proto或者message.proto 4 接口安全规范略 5 参数类型定义5.1 EVENT_TOUCH-触摸消息 参数名称 参数编码 参数类型 描述 触摸类型 action int32 触摸X点 x float 触摸Y点 y float 5.2 EVENT_KEY-按键消息 参数名称 参数编码 参数类型 描述 事件类型 KeyEvent enum 0,DOWN,1,UP,2.PRESS 按键码 keyCode int32 5.3 EVENT_VOLUME-声音事件（之后重构优化） 参数名称 参数编码 参数类型 描述 音量类型 volumeType enum UP,上行音量 DOWN,下行音量 5.4 GET_APP 获取当前栈顶activity 参数名称 参数编码 参数类型 描述 5.5 EVENT_DESOTRY-Activity关闭 参数名称 参数编码 参数类型 描述 包名 packageName String 应用包名 Activity名称 acitivityName String 应用activity名称 5.6 GET_PROPERITES获取盒子相关属性 参数名称 参数编码 参数类型 描述 属性key name String CA,MAC,DEVICEID 属性value value String 属性值 5.7 GET_VERSION 版本同步暂无使用 5.8 GET_SERVER 设备发现 参数名称 参数编码 参数类型 描述 设备ip ip String 设备ip 5.9 EVENT_HOME HOME处理5.10 EVENT_MESSAGE 自定义通道上层app，自定义通信消息类型 5.11 EVENT_GSENSOR sensor信息 参数名称 参数编码 参数类型 描述 Sensor values values float Sensor values Sensor 容量 accuracy int Sensor 容量 Sensor 时间戳 timestamp long Sensor 时间戳 Sensor sensor Sersor 具体定义参照代码 //TODO播控消息已挪至app层自定义，如需参考，请黄海添加 //TODO其它如广告等后增加的消息类型，请相关开发人员添加 1 URemoteSdk接入1.1.1 遥控端接入流程URemoteSdk目前是作为Andorid第三方依赖工程接入的，之后可能只提供AAR包的方式。本样例只提供Android-studio作为IDE的接入方式，其余IDE类同。 1）工程导入URemoteSdk 配置文件： build.gradle: 添加 12345dependencies &#123; compile project(&apos;:uremotesdk&apos;)&#125; setting.gradle：添加 1include &apos;:app&apos;, &apos;:uremotesdk&apos; 以上内容添加依赖库后，一般都会自动添加。 2）URemoteSdk 初始化 接入SDK的APP，在对应Application中进行初始化： 1URemoteSdk.getInstance().init(URemoteConfig.createDefault(this)); init参数可以自定义，具体请参考相应代码。 3）具体通讯指令支持自定义，与业务相关的具体通讯指令自定义处理，这里提供样例如下： 自定义指令添加位置建议如下： 消息定义参照如下：message.proto OnPageRequest:业务场景ViewPager切换分页指令。 4）接口请求： 123456789Wire.Envelope envelope = Wire.Envelope.newBuilder().setType(Wire.MessageType.EVENT_MESSAGE) .setId(MainIDs.ID_PAGE) .setMessage(com.realer.service.proto.Message.OnPageRequest.newBuilder() .setIndex(indexRadioButton.getIndex()).build().toByteString()).build();URemoteSdk.getInstance().getAgent().onMessage(envelope,null); 自定义消息方法说明： URemoteSdk.getInstance().getAgent().onMessage(Wire.Envelope envelope,OnMessageListener listener) 参数说明： envelope:具体指令消息内容，参照上文提到的protobuf定义。 listener:是否需要回调同步处理，不需要可以传NULL. 5)遥控器和盒子连接状态监听 如果不做特殊处理，采用默认UI交互，APP 抽象基础Activity继承RemoteActivity或者RemoteFragmentActivity. 如果自己处理，监听，更新自定义UI: 动态注册广播： 1234567receiver = new RemoteReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(URemoteState.ACTION_STATE_CHANGE);registerReceiver(receiver,intentFilter); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class RemoteReceiver extends BroadcastReceiver &#123; private static final String TAG = &quot;RemoteReceiver&quot;; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if(action.equals(URemoteState.ACTION_STATE_CHANGE))&#123; int state = intent.getIntExtra(URemoteState.EXTRA_STATE,-1); String info = intent.getStringExtra(URemoteState.EXTRA_INFO); Log.d(TAG,&quot;state&quot; + state); switch (state)&#123; case URemoteState.STATE_CONNECTED: PromptDialog.close(); break; case URemoteState.STATE_CONNECTING: PromptDialog.show(RemoteActivity.this,info,false,null); PromptDialog.hideBottom(); break; case URemoteState.STATE_DISCONNECTED: PromptDialog.show(RemoteActivity.this,info,false,null); PromptDialog.showBottom(); break; &#125; &#125; &#125;&#125; URemoteState: STATE_CONNECTED:已连接 STATE_CONNECTING:连接中 STATE_DISCONNECTED:已断开 6）右上角悬浮菜单 同5，如果采用默认集成，集成方式如下： 对应要显示得Activity中添加： 123456789101112131415161718192021@Overrideprotected void onResume() &#123; super.onResume(); URemoteSdk.getInstance().showMenu();&#125;@Overrideprotected void onPause() &#123; super.onPause(); URemoteSdk.getInstance().hideMenu();&#125; 注意：以上悬浮菜单，连接异常处理，物理返回键，触摸如果整个APP内都集成得话，建议抽象BaseActivity进行处理，另，触摸事件得处理，最好是只传输过程，不传输结果，以免最终结果状态不对应，即ACTION_UP不做指令传递。 具体可参照C_URemoteSdk中的RemoteActivity或者RemoteFragmentActivity. 1.1.2 盒子端接入流程1）工程导入，同遥控端导入方式 2）URemoteSdk初始化，同遥控端初始化方式 3）消息注册监听： 12345678910111213@Overrideprotected void onResume() &#123; super.onResume(); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().registerActivityCallback(messageCallback); &#125;&#125; 12345678910111213@Overrideprotected void onPause() &#123; super.onPause(); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().unregisterActivityCallback(messageCallback); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 /** * 对应消息处理 */private Handler messageHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Wire.Envelope envelope = (Wire.Envelope)msg.obj; try &#123; switch(msg.what)&#123; case MainIDs.ID_PAGE: com.realer.service.proto.Message.OnPageRequest pageRequest = com.realer.service.proto.Message.OnPageRequest.parseFrom(envelope.getMessage()); if(pageRequest != null &amp;&amp; vp != null)&#123; IndexRadioButton indexRadioButton = (IndexRadioButton)title_group.getChildAt(pageRequest.getIndex()); indexRadioButton.setFocusable(true); indexRadioButton.requestFocusFromTouch(); indexRadioButton.requestFocus(); vp.setCurrentItem(pageRequest.getIndex()); &#125; break; default: break; &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;/** * 消息接收 */private IMessageCallback.Stub messageCallback = new IMessageCallback.Stub() &#123; @Override public void onMessage(byte[] msg) throws RemoteException &#123; try &#123; Wire.Envelope envelope = Wire.Envelope.parseFrom(msg); if(envelope.getType() != Wire.MessageType.EVENT_MESSAGE)&#123; Log.d(TAG,&quot;invalid message&quot;); return; &#125; //id区分业务类型，０，默认跳转activity Message handlerMsg = new Message(); handlerMsg.what = envelope.getId(); handlerMsg.obj = envelope; messageHandler.sendMessage(handlerMsg); &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125;&#125;; 4）状态通知，App内所有Activity，onResume要发送推送消息，样例： 123456789101112131415@Overrideprotected void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onActivityNotify&quot;); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().onNotifyState(State.REDRAW); &#125;&#125; State 状态：REDRAW 重绘 ​ MIRROW 镜像 ​ DIFF 异步 注意：以上状态通知，是要求APP必须接入得，消息注册依据自己业务而定，同遥控端接入一样，基础操作仍然可以抽象BaseActivity处理。 具体可参照S_URemoteSdk中的RemoteActivity或者RemoteFragmentActivity. 1.2 接口说明1.2.1 获取CA卡用户遥控端可以通过C_URemoteSdk,获取盒子CA卡信息： 1URemoteSdk.getInstance().getAgent().getProp(Properties.CA) 1.2.2 获取盒子设备ID1URemoteSdk.getInstance().getAgent().getProp(Properties.DEVICEID); 1.2.3 获取盒子设备MAC1URemoteSdk.getInstance().getAgent().getProp(Properties.MAC); 1.2.4 获取盒子状态（重绘，镜像，异步）1URemoteSdk.getInstance().getAgent().getState() State 状态：REDRAW 重绘 ​ MIRROW 镜像 ​ DIFF 异步 1.2.5 获取盒子音量1URemoteSdk.getInstance().getAgent().getVolume() 1.2.6 物理Key事件1URemoteSdk.getInstance().getAgent().onKeyEvent(KeyEvent.KEYCODE_BACK, com.realer.remote.client.protocol.KeyEvent.UP); 1.2.7 物理Touch事件1URemoteSdk.getInstance().getAgent().onTouchEvent(motionEvent.getAction(), x, y); 1.2.8 直播频道换台(不建议使用了，可以自定义消息处理）1URemoteSdk.getInstance().getAgent().onChannelChange(&quot;1000001&quot;); 1.2.9 播控相关事件//TODO ，已挪至上层app，走自定义消息通道，如需参考，请黄海添加 1.2.10 server端callback回调IHomeCallback: home 按键处理 IADCallback: 广告事件处理 IMessageCallback 自定义事件回调 IChannelCallback 频道切换回调 IPlayerCallabck 播控回调 具体注册，和注销请参照具体sdk代码 1.2.11 client端ListenOnAppListen 栈顶app OnMessageListen 消息listen OnMiniCapListen 镜像listen OnURemoteListen 设备发现listen OnPlayerListen 播控listen 具体注册，和注销请参照具体sdk代码 1.2.12 自定义通道1client 主动消息发送通用接口: OnMessage void onEvent(final byte[] message); server 主动推送消息通用接口: OnNotify void onNotify(final byte[] notify); 注：像瀑布流，ListView,GridView,ScrollView等这些滑动控件，建议实现监听滑动跟踪X,Y信息给到盒子端通过自定义消息处理测试下。目前像触摸，key事件 是在service里通过instrument 底层注入得方式，样例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private class EventWorker extends Thread &#123; @Override public void run() &#123; while (!isInterrupted()) &#123; try &#123; Wire.TouchEventRequest touchEventRequest = eventMsgs.take(); if (touchEventRequest != null) &#123; final float touchX = touchEventRequest.getX() * Constants.SERVER_WIDTH / Constants.CLIENT_HEIGHT; final float touchY = touchEventRequest.getY() * Constants.SERVER_HEIGHT / Constants.CLIENT_WIDTH; Log.d(TAG, &quot;input--x&quot; + touchX + &quot;--y--&quot; + touchY); instrumentation.sendPointerSync( MotionEvent.obtain( SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), touchEventRequest.getAction(), touchX, touchY, 0)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125; &#125; 具体那种方案更优，需后期测试。 1.3 ProtoBuf接入说明Probobuf类似JSON得数据通讯协议，效率接近于二进制流，比JSON效率高很多。 Android-Studio 接入方式： app的build.gradle配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293apply plugin: &apos;com.android.application&apos;apply plugin: &apos;com.google.protobuf&apos; //protobuf插件buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; //添加依赖 classpath &apos;com.google.protobuf:protobuf-gradle-plugin:0.8.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;android &#123; .......... //此处省略基础配置 sourceSets &#123; main &#123; java &#123; srcDir &apos;src/main/java&apos; &#125; proto &#123; //指定probuf文件位置 srcDir &apos;src/main/proto&apos; &#125; &#125; &#125;&#125;protobuf &#123; //protobuf插件编译任务 protoc &#123; artifact = &apos;com.google.protobuf:protoc:3.1.0&apos; &#125; generateProtoTasks &#123; all().each &#123; task -&gt; task.builtins &#123; remove java &#125; task.builtins &#123; java &#123; &apos;src/main/java&apos; &#125; // Add cpp output without any option. // DO NOT omit the braces if you want this builtin to be added. cpp &#123;&#125; &#125; &#125; &#125;&#125; 可参照URemoteSdk build.gradle配置 1.4 URemoteSdk 调试及安装URemoteSdk ，同时支持插件和独立APP的调试，三方APP在遥控器端最终是作为插件运行的。但是插件得方式不利于开发人员调试，所以该SDK同时支持 独立APP调试运行。 前置条件： C_URemoteService.apk 遥控器端Service。 adb push C_URemoteService.apk /system/app 重启遥控器 S_URemoteService.apk 盒子端Service。 adb push S_URemoteService.apk /system/app 重启盒子 1）独立APP调试（独立APP只做调试使用，不做最终安装部署） 通过6.1.1，6.1.2流程接入URemoteSdk后，直接安装或者adb push 都可以，app在data分区还是system分区都可以 2）插件调试，安装 通过6.1.1，6.1.2流程接入URemoteSdk后， adb push 对应APP到sdcard分区根目录。具体名称要和插件HOST程序商议协定。 以上调试和安装都是指双端APK包。 参考样例c_setting 工程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
