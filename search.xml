<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大话排序算法－选择排序]]></title>
    <url>%2F2018%2F05%2F20%2Falgorithm_select%2F</url>
    <content type="text"><![CDATA[选择排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法练习]]></title>
    <url>%2F2018%2F05%2F18%2Falgorithm%2F</url>
    <content type="text"><![CDATA[插入排序，冒泡排序，选择排序Python版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# coding:UTF-8import random# 随机数def get_andomNumber(num): lists=[] i=0 while i&lt;num: lists.append(random.randint(0,100)) i+=1 return lists# 插入排序def insert_sort(lists): for i in range(1,len(lists)): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j],lists[j+1] = key, lists[j] j -= 1 return lists#冒泡排序def buddle_sort(lists): count = len(lists) - 1 for i in range(0,count): for j in range(0,count-i-1): if lists[j] &gt; lists[j+1]: lists[j],lists[j+1] = lists[j+1],lists[j] return lists#选择排序def select_sort(lists): count = len(lists) - 1 for i in range(0,count): k = i; for j in range(k+1,count + 1): if lists[j] &lt; lists[k]: k = j if k != i: lists[k],lists[i] = lists[i],lists[k] return listsa = get_andomNumber(10)print(&quot;排序之前：%s&quot; %a)b = insert_sort(a)print(&quot;插入排序：%s&quot; %b)c = buddle_sort(a)print(&quot;冒泡排序：%s&quot; %c)m = select_sort(a)print(&quot;冒泡排序：%s&quot; %m)#时间复杂度f(n) = 1 + 2 + ...+n-1 = n^2/ 2 - n/2,所以O(f(n)) = n^2 Java 版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import javax.sound.midi.Soundbank;import java.util.Random;/** * Created by zhanghailiang on 18/5/20. */public class SortUtil &#123; public static int[] random()&#123; int count = 10; int[] datas = new int[count]; for(int i = 0; i &lt; count; i++)&#123; datas[i] = new Random().nextInt(98) + 1; System.out.print(datas[i] + " "); &#125; return datas; &#125; public static int[] insertSort(int[] datas)&#123; int count = datas.length; for(int i = 0; i &lt; count - 1; i++)&#123; int j = i; while (j &gt;= 0)&#123; if(datas[j + 1] &lt; datas[j])&#123; int temp = datas[j + 1]; datas[j + 1] = datas[j]; datas[j] = temp; &#125; j--; &#125; &#125; return datas; &#125; public static int[] buddleSort(int[] datas) &#123; int count = datas.length; for(int i = 0; i &lt; count - 1; i++)&#123; for(int j = 0; j &lt; count - i - 1; j++)&#123; if(datas[j] &gt; datas[j+1])&#123; int temp = datas[j + 1]; datas[j + 1] = datas[j]; datas[j] = temp; &#125; &#125; &#125; return datas; &#125; //非相临交换 public static int[] selecSort(int[] datas)&#123; int count = datas.length; for(int i = 0; i &lt; count - 1; i++)&#123; int min = i; for(int j = i+1; j &lt; count; j++)&#123; if(datas[j] &lt; datas[min])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = datas[min]; datas[min] = datas[i]; datas[i] = temp; &#125; &#125; return datas; &#125; public static void main(String[] args) &#123; int[] datas = SortUtil.random(); int[] results = SortUtil.selecSort(datas); System.out.printf("\r\n"); for(int i = 0; i &lt; results.length; i++)&#123; System.out.printf(results[i] + " "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker vs vps]]></title>
    <url>%2F2018%2F05%2F18%2Fdocker_1%2F</url>
    <content type="text"><![CDATA[Docker vs vpsThe perspective on containers is very different between the 2. In short OpenVZ sees a container as a VPS, and docker sees a container as an application/service. What does this imply? For OpenVZ you can expect that when you create containers, its sort of like making Virtual Servers. OpenVZ has interfaces focussed on setting up VPS containers that you decorate yourself manually. Therefore they provide templates for empty linux machines that you can start up and shut down, that you afterward SSH into, to set them up yourself with whatever you need, like a LAMP stack. When you would want to set up a LAMP stack, you would do it like you usually do when you set up a new server. You get an empty linux machine with a virtual ethernet adapter that has its own publicly accessible WAN IP with Ubuntu on it, access it with SSH, and you install all required services in it using your average package manager (yum or apt) and do the setup required in config files yourself. For Docker, you can expect that when you create containers, the container is a single application, that just does ONE thing. Hence, it might need some other containers to help it. (For example a container that provides a database) Docker made it very easy to define whats inside a container without having to actually start one up, and constantly create new exactly equals instances of this container. They define the contents of a docker container (the image) by using very lightweight templates that they call Dockerfiles. There is a huge set of dockerfiles already out there, that you can find in the Docker hub, take a look yourself (its like being in a candy shop with free candy! :D): docker hub. The images produced by these dockerfiles can be pulled with the docker CLI tool, by using a pull command. In docker theres also easy access to stuff like port forwarding, virtual directories (so that you can acces files on the host machine easily) and things alike that any executable could use. The perspective on containers is very different between the 2. In short OpenVZ sees a container as a VPS, and docker sees a container as an application/service. What does this imply? For OpenVZ you can expect that when you create containers, its sort of like making Virtual Servers. OpenVZ has interfaces focussed on setting up VPS containers that you decorate yourself manually. Therefore they provide templates for empty linux machines that you can start up and shut down, that you afterward SSH into, to set them up yourself with whatever you need, like a LAMP stack. When you would want to set up a LAMP stack, you would do it like you usually do when you set up a new server. You get an empty linux machine with a virtual ethernet adapter that has its own publicly accessible WAN IP with Ubuntu on it, access it with SSH, and you install all required services in it using your average package manager (yum or apt) and do the setup required in config files yourself. For Docker, you can expect that when you create containers, the container is a single application, that just does ONE thing. Hence, it might need some other containers to help it. (For example a container that provides a database) Docker made it very easy to define whats inside a container without having to actually start one up, and constantly create new exactly equals instances of this container. They define the contents of a docker container (the image) by using very lightweight templates that they call Dockerfiles. There is a huge set of dockerfiles already out there, that you can find in the Docker hub, take a look yourself (its like being in a candy shop with free candy! :D): docker hub. The images produced by these dockerfiles can be pulled with the docker CLI tool, by using a pull command. In docker theres also easy access to stuff like port forwarding, virtual directories (so that you can acces files on the host machine easily) and things alike that any executable could use. If you would want a LAMP stack in docker, all you do is “docker run -d -p 80:80 tutum/lamp” This pulls the image tutum/lamp, and runs daemonised (-d) it with port 80 from the container forwarded to the port 80 of the host, exposing the inner webservice to the outside. As you can see, it does not have its own IP address in contrast to an OpenVZ machine. And its just like its an apache server running on your root machine. The advantage compared to installing it natively, is that docker makes the installation a lot easier and unlimitedly replicable. Also it doesn’t clutter your host machine with lots of files, and supplies a security boundary around your application. 注：openVZ 是实现vps的一种虚拟技术，所以这里直接拿它来做比较。 简译: 两者在对容器的解读上有很大的不同。 简而言之，openVZ 它是把容器作为vps，而docker 把容器作为应用程序服务。 OpenVZ 它就是一个linux服务器，你可以和操作独立服务器一样，ssh登陆，安装软件包，比如LAMP。 它带有虚拟以太网适配器，可以有自己的独立ip. Docker 它是单个应用程序，只做一件事，就像是服务器上运行的apache 没有自己的独立ip 优势就是它有docker hub，安装容易并且可以无限复制]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web服务一些概念理解]]></title>
    <url>%2F2018%2F05%2F17%2Fserver%2F</url>
    <content type="text"><![CDATA[关于服务器服务器种类介绍 独立服务器 机房里实实在在的物理服务器，也可以理解为高配版的pc机。 vps (虚拟专用服务器） 独立服务器通过虚拟化技术虚拟出多个专用服务器。 云服务ECS(Elastic Compute Service) 建立在服务器集群之上的，可以理解为，也是通过虚拟化技术整合多台独立服务器资源的弹性服务器。 虚拟主机 一个独立主机或者vps服务器上，可以运行多个站点的技术。通俗的理解: 云服务可以看作是大酒店，独立服务器可以认为是酒店的房间，vps 理解为房间的卧室，虚拟主机理解为卧室里一个床位。 你买了一个云服务，相当于你定了一个房间(这里只是比喻，这里并不一定是独立服务器），不够用随时加订，每一间卧室（vps)都可以睡觉，看电视，拉便便，但是虚拟主机就只能让你睡觉（部署站点用）。 服务器应用场景介绍 独立服务器 就是想要有自己的机房（比如大厂，企事业单位等） 服务器租赁提供商 虚拟主机 企业网站，个人博客(可参照阿里云理解https://wanwang.aliyun.com/hosting) vps 适用于小型Web应用、轻量应用等低负载、突发型应用场景(可参照理解https://www.aliyun.com/product/swas 阿里云已提供系统镜像，应用镜像两种) 云服务(弹性服务) 企业应用，视频编码等高耗cpu负载的场景 关于apache http server, tomcat, nginx严格来说，apache http server/nginx 应该叫做HTTP Server(当然nginx可以作为邮件服务，Tcp服务适用）,tomcat 是AppServer，他们都可以： 运行在上面说的服务器上，通过绑定服务器的ip地址，并监听某个tcp端口来接受并处理http请求。 通过配置，生成多个虚拟主机 他们不同在于： apache http server/nginx 可以做代理，负载均衡，处理静态资源(就是不同客户端看到的东西是一样的)。 tomcat 可以处理动态资源（就是不同客户端看到的东西是不一样的）。 所以一般tomcat 是和nginx配合使用的： 动静资源分离，通过nginx反向代理功能，分发请求，动态资源交给tomcat,而静态资源直接邮nginx返回，这样大大减轻tomcat压力。 负载均衡，业务压力增大时，一个tomcat 不足以处理时，可以启动多个tomcat实例进行水平扩展,而nginx的负载均衡功能可以把请求分发到不同的tomcat实例上。 以上web server都能作为虚拟主机配置使用，具体虚拟主机的配置策略有以下几种： 基于ip 把下面基于域名的配置的地方改为对应ip就可以，如果您的网站有强烈seo需求，可以配置独立外网ip。 基于域名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&gt; &lt;!-- 360停车--&gt;&gt; &gt; &lt;Host name="www.360park.com.cn" appBase="webapps/360park"&gt; &gt; unpackWARs="true" autoDeploy="true"&gt;&gt; &gt; &lt;!-- SingleSignOn valve, share authentication between web applications&gt; &gt; Documentation at: /docs/config/valve.html --&gt;&gt; &gt; &lt;!--&gt; &gt; &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;&gt; &gt; --&gt;&gt; &gt; &lt;Context path="" docBase="/rs/tomcat_web/webapps/360park" debug="0" reloadable="true" /&gt;&gt; &gt; &lt;!-- Access log processes all example.&gt; &gt; Documentation at: /docs/config/valve.html&gt; &gt; Note: The pattern used is equivalent to using pattern="common" --&gt;&gt; &gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"&gt; &gt; prefix="localhost_access_log." suffix=".txt"&gt; &gt; pattern="%h %l %u %t %r %s %b" /&gt;&gt; &gt; &lt;/Host&gt;&gt; &gt; &lt;!-- 新锐友信--&gt;&gt; &gt; &lt;Host name="www.realer.cn" appBase="webapps/tonghang"&gt; &gt; unpackWARs="true" autoDeploy="true"&gt;&gt; &gt; &lt;Alias&gt;realer.cn&lt;/Alias&gt;&gt; &gt; &lt;Alias&gt;www.realer.cn&lt;/Alias&gt;&gt; &gt; &lt;!-- SingleSignOn valve, share authentication between web applications&gt; &gt; Documentation at: /docs/config/valve.html --&gt;&gt; &gt; &lt;!--&gt; &gt; &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;&gt; &gt; --&gt;&gt; &gt; &lt;Context path="" docBase="/rs/tomcat_web/webapps/tonghang" debug="0" reloadable="true" /&gt;&gt; &gt; &lt;!-- Access log processes all example.&gt; &gt; Documentation at: /docs/config/valve.html&gt; &gt; Note: The pattern used is equivalent to using pattern="common" --&gt;&gt; &gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"&gt; &gt; prefix="localhost_access_log." suffix=".txt"&gt; &gt; pattern="%h %l %u %t %r %s %b" /&gt;&gt; &gt; &lt;/Host&gt;&gt; &gt; &gt; &gt; 基于端口 12345678910111213141516171819202122232425&gt; &lt;Service name="myService1" &gt;&gt; &lt;Connector port="9081"/&gt;&gt; &lt;Engine name="myEngine1" defaultHost="test1" &gt;&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt;&gt; &lt;Host name="test1" appBase="webapps1" /&gt;&gt; &lt;/Engine&gt;&gt; &lt;/Service&gt;&gt; &gt; &gt; &lt;Service name="myService2" &gt;&gt; &lt;Connector port="9082"/&gt;&gt; &lt;Engine name="myEngine2" defaultHost="test2" &gt;&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt;&gt; &lt;Host name="test2" appBase="webapps2" /&gt;&gt; &lt;/Engine&gt;&gt; &lt;/Service&gt;&gt; &gt; &lt;Service name="myService3" &gt;&gt; &lt;Connector port="9083"/&gt;&gt; &lt;Engine name="myEngine3" defaultHost="test3" &gt;&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase" /&gt;&gt; &lt;Host name="test3" appBase="webapps3" /&gt;&gt; &lt;/Engine&gt;&gt; &lt;/Service&gt;&gt; 具体另外两个配置可自行百度，差不多，以上提供tomcat配置指南，实际中如果是静态网页的官网需求，最好是用nginx。 正向代理 和 反向代理 你想访问被墙掉的谷歌，你可以买一个vpn。这个vpn是你买的，是代理你去向谷歌发起请求的。 你想访问百度，会有一个转发，到百度内网，对于你来说你不知道，也不关心，它是代理百度内部的服务。 所以正向代理和反向代理的说法是相对的,但是通常描述都是以客户端为对照方（即发起请求方） 关于高并发负载均衡做什么用的呢？其实可以按照动词的方式理解，反过来均衡负载，就是你的业务负载高的时候，通过一些技术手段均衡你的业务负载，解决高并发问题，高并发瓶颈一般在应用服务和数据库服务上。 应用服务负载均衡？ 硬负载 F5 Array 软负载 dns dns负载均衡是通过DNS服务器实现的，主要用于把请求均匀的分布到nginx服务器上。其实真是情况中可能是用来根据地域区分请求。但是一个地域中的请求还算需要均匀的分配到nginx服务器上的。 有两个缺点：一个是无法区分服务是否挂掉，即时某个NGINX服务器挂掉了，DNS仍然会分配。另一个是DNS缓存的问题，用户访问网站，网站域名被DNS服务器解析为某个IP。这个IP一般情况都会在客户端本地进行缓存，短时间内下次再访问这个域名，会直接从缓存中拿，无法达到真正的均匀，但这对服务器影响不算太大。重要的请求个数无法真正的做到均衡，比如每个Nginx服务器拿到100个请求，但是所有的耗时大请求都集中到某一台服务器中，那么这个服务器压力将会很大。其他的会比较空闲。 lvs 基于网络七层协议第四层，针对高可伸缩、高可用网络服务的需求，我们给出了基于IP层和基于内容请求分发的负载平衡调度解决方法，并在Linux内核中实现了这些方法，将一组服务器构成一个实现可伸缩的、高可用网络服务的虚拟服务器。 nginx 基于网络七层协议上第七层（应用层），配置简单，nginx是目前流行的，优秀的反向代理服务器（其实他不仅仅是反向代理服务器，还是web服务器，也可以是邮件代理服务器，感谢俄罗斯人的智慧）。nginx作为反向代理服务器，主要负责把请求均匀的分摊到应用服务器中。为了达到均匀，Nginx有五种负载均衡策略。 轮询 请求依次轮流往每个应用服务器上进行分配，分配策略比较简单。缺点：不均匀，可能会出现，某些服务器接受的请求较重，负载压力重，有些负荷小，不可控。另外服务器之间需要进行session同步。 权重轮询 在轮询的基础上给每个应用服务器一定的权重，比如三台服务器，权重设置为 0.4:0.4:0.2。来到10个请求（序号1到10），那么根据轮询以及权重，序号1、4、 6、 9的请求会打到 第一台服务器上，序号 2、 5 、7 、10 的请求会打到第二台服务器上，剩余序号3 、 8的 请求打到第三台服务器上。优点：可以根据情况进行调整。可控，仍然需要进行session同步。 IP-hash 优点：无需进行session同步，固定IP会固定访问一台服务器。缺点：恶意攻击，会造成某台服务器压垮。提供的服务不同，面向的地区不同，IP可能会出现集中，造成不均匀，不可控。 fair 这种相当于自适应，会根据服务器处理请求的速度进行负载均衡分配。处理请求最早结束的，拿到下一个请求。看上去是不是很好。但是一般都不使用，说是考虑到网络不稳定因素。还有待研究。这种也需要进行session同步。 URL-hash 这种是根据URL进行hash，这样某些请求永远打某台服务器。利于利用服务器的缓存，但是可能由于URL的哈希值分布不均匀，以及业务侧重造成某些服务器压力大，某些负荷低。这种也需要进行session同步。 目前比较流行的配置是使用第二种进行配置，但是实际生产中还是需要根据业务特点进行配置，每种策略都具有每种策略的优缺点。 haproxy 数据库负载均衡? 读写分离 spring应用层解决方案，配置多个数据源 中间件 mysql-proxy :https://downloads.mysql.com/archives/proxy/ Amoeba for MySQL:http://docs.hexnova.com/amoeba/ 分库分表 spring应用层解决方案，http://shardingjdbc.io/ 中间件 mycat:http://www.mycat.io/ 关于高可用 高可用： 负载均衡主备 nginx+keepalived 参考配置https://www.jianshu.com/p/b147a719f740 lvs+keepalived (图转) 数据库主备 关于高性能高性能： http缓存服务器：squid/varnish/nginx cache ,按osi,应该属于应用层 存储缓存服务器: redis/memcached，按osi,属于存储阵营，应该属于表示层 所以一般的服务器部署架构可以这样 F5/LVS(keepalived)&lt;—&gt;Haproxy/nginx&lt;—&gt;Squid/Varnish&lt;—&gt;AppServer&lt;—&gt;redis/memcached&lt;—&gt;db。 关于压测 AB jemeter loadrunner httpload 三方云测试平台 关于童鞋提出的两疑问点？vps, vm, docker 区别？请参照 http://yuhengzhang.cn/2018/05/18/docker_1/ http://yuhengzhang.cn/2018/05/17/docker/]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker vs vm]]></title>
    <url>%2F2018%2F05%2F17%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker vs VM 注: 关于docker 里，宿主os和容器os必须相同，这点是错误的。宿主os和容器os是可以不同的，但是 ​ 目前容器os只能是linux。作者这里描述不同，是因为没考虑windows上跑docker.应为windows 上 ​ 跑docker，其实底下跑了linux vm的。 ​ docker 引擎的基础是linux自带的容器（lxc)技术，容器的应用是在它们自己的空间上共享宿主内核。这也是为 什么容器os只能是linux原因]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2018%2F05%2F13%2Fresume%2F</url>
    <content type="text"><![CDATA[联系方式 手机：13263369194 邮箱：hailianglone@gmail.com,hailianglong@126.com QQ: 317824594 简历线上版：http://yuhengzhang.cn/2018/05/13/resume，密钥：zhanghl 个人信息 张海亮／男／1985 本科／河北大学（数学与计算机系） 工作年限： 9年 工作经历：1年J2ME方向，4年Android方向，4年JavaWeb方向 技术博客： http://yuhengzhang.cn (很汗颜，刚搭建) GitHub： http://github.com/hailianglone 期望职位 ：web高级研发工程师，系统架构师 期望薪资：税前月薪不低于35K，可面议，期权或股份特别的可例外 期望城市：北京 工作经历北京新锐友信软件技术有限公司（2013年5月～至今）职位：技术合伙人 产品聚合支付（明付平台）(web)明付平台是集支付宝，微信，京东，翼支付，银联二维码等平台之上的三方支付服务商平台，旨在帮助企业迅速便捷的接入相关支付的开放平台，目前SDK已开放的支付包含： 一码付（商户提供一个二维码付款码，同时支持用户微信和支付宝主扫发起的支付） 刷卡付 （用户出示手机App钱包付款码，由商户主扫发起的支付，目前支持微信，支付宝，京东，翼支付，银联二维码，和包支付） 微信公众号支付 微信小程序支付 微信动态码支付 目前已接入商户列表： 北京华联综超（对应门店62家） 柏溪商贸 萌优集 华联西安skp (马上接入) 该平台服务端架构设计，研发，部署运维，基本是本人一人负责，目前日流水600w，订单量100w单，SDK还未已开放方式发布。 小咖停车(web and android)小咖停车是基于简单IOT蓝牙通信技术，通过App和智能地锁的配合，用来解决停车难的问题，产品本来定位的写字楼和附近小区的错时停车，目前由于小区物业，居委会等等一系列问题，正在尝试海外日本市场，国内已接入小区和写字楼： 牡丹园西里 知春路荣上居 有研院 首钢停运（大洋路市场，暂未对外开放） 日本福冈（洽谈中） 该平台服务端和Android客户端设计与研发基本由本人一人负责。 下载链接：http://www.360park.com.cn 零钱彩(web)零钱彩是彩票和零售的一种结合创新，目前已在华联部分超市试运营，由于本产品主属兄弟公司，业务和模式上暂处保密状态，不便多说。 本平台第一版本服务器端是本人一人进行设计和研发，目前该产品已获PreA融资。 小程序版： 项目北京华联是我们主要的客户，目前为华联提供的服务有： pos 收银 posserver 收银服务端 crm 支付 公众号 自助购 北京华联CRM系统(web)北京华联crm系统是针对华联信息系统整个闭环系统中关于会员系统的解决方案，零售行业的会员系统是所有crm系统中最为复杂的，已实现主要功能列表如下： 组织机构和门店管理 员工管理，菜单管理和角色权限管理 基础设置（俱乐部设置，积分权益设置，销售权益设置，支付权益设置） 积分返利，积分抵现，积分返礼 促销管理（折扣促销，优惠券促销，积分促销） 会员卡服务台 办卡自动化处理 简单审批 报表系统 该系统研发团队3人，本人主要负责项目跟踪和实施，以及对接基础设置模块和促销管理模块，为pos系统提供crm核心api接口实现。 北京华联公众号系统（web)华联公众号系统是华联为了集中管理各个地区公众号营销以及电子会员管理而定制的公众号系统开发，系统功能列表： 粉丝自动划分地区 分地区设置海报，本地特色，热销榜单，自由品牌，每月上新 电子会员 会员课堂 BHG服务（电子发票，会员权益，附近门店，意见反馈，常见问题） 分地区招聘设置 该系统需求和服务端设计，研发及部署运维，本人一人负责。 国安盒子触控遥控器(android)本系统是另一个初创团队的项目，一期主要本人负责和带队，遥控器广州地区一小批量量产，该遥控器是基于android原生系统定制，不同于目前市场上的智能遥控器，触控遥控器的本质是反向了小屏投大屏的模式，它是把电视屏幕投到遥控器屏幕附带红外控制功能，投屏模式分为镜像同屏和重绘同屏模式，系统架构为了后来要做平台的需求，架构设计如下： 其它项目 优驾行（陕西优驾行）(android) 掌中宝 （圣元国际）（web and android) 国网直升机调度系统（国家电网）（web) 烤圈（海尔）（android) 黄金60s（外包，湖南卫视）（android) 宝宝讲故事（外包，金和）（android) 微视（外包，cctv)（android) 中科创达科技股份有限公司（2011年9月～2013年5月）职位：subleader 展讯8810，6810等项目（抱歉有些实在记不清楚了）本人主要担任app小组subleader,团队4～6人，主负责模块： Contacts （联系人） Launcher（主界面） LockScreen （锁屏） Setting （设置） QuickSearchBox（搜索） InputMethod（输入法） 北京捷通华声（2009年9月～2011年9月）职位：研发工程师 天行输入法主打手写输入，支持全屏手写，窗口书写，字体支持颜色设置，大小设置，简繁体设置以及毛笔等格式设置，以及更牛逼的行识别。当然手写识别和语音识别是公司核心，该部分都在公司研发总监手上，我们是so库方式集成接入。 其它项目J2ME 相关，诺基亚N71（塞班系统）的时代了。 开源项目和作品初创团队，你懂得，除了工作基本都没有思考的时间，只是短暂参与过iBase4j 的项目，除了提了问题和提供swagger-ui支持，基本没有参与过什么。 https://gitee.com/iBase4J/iBase4J 注：以上所有web项目基本架构都是： spring/springmvc+mybatis+mysql/oracle+redis+shiro+swagger+fastdfs+nginx+tomcat 数据库支持读写分离 nginx做反向代理和负载均衡 swagger在线接口文档输出 shiro 权限管理 redis 缓存服务器和session共享 shardingjdbc/mycat 两种分库分表方案（暂时没有用到哦） fastdfs 文件和图片服务器 技能清单 Web开发：spring/springmvc/mybatis/hibernate/jpa/mysql/oracle/sqlite/redis（熟悉），structs/springboot/ejb/python/nosql/nodejs（了解） Web前端：jsp（熟悉），jquery/vue/argularjs（了解），react（知道有） 版本管理，文档和自动化部署工具：/cvs/svn/git/jenkins/redmine（熟悉），docker（了解） 包管理：/ant/maven/gradle（熟悉）, npm/yarn（前端了解） 单元测试：junit 文件存储：/ftp/fastdfs （熟悉） Linux 常用命令 Web容器：/nginx/tomcat（熟悉），weblogic/jetty （了解） Android：app/framework 云和开放平台：阿里云/腾讯云/ecs/oss/rds，七牛云，亚马逊云（马上要），/微信支付平台/微信公众平台/微信开放平台/蚂蚁金服开放平台／微博开放平台／腾讯开放平台／科大讯飞语音云／容联云短信／友盟统计／极光推送／环信通信／TestIn测试平台／银联开放平台／京东金融开放平台／电信翼支付开放平台／，openfire(了解) 分布式与大数据：dubbo/zookeeper/hadoop/spark/storm等（本人只是略知，毕竟目前实际项目未用到） 常用传输数据结构：/xml/json/protobuf 注：初创团队兼任scm和运维部署，负责/redmine/gitlab/jenkins/svn等服务搭建，以及产品和项目发布。 致谢感谢您花时间阅读我的简历，期待有机会与您一起共事。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2018%2F05%2F13%2Fkownledge%2F</url>
    <content type="text"><![CDATA[mac 拼音选择框不见？打开 Terminal （命令行），输入下面，回车即可。 1pkill -f SCIM.app Linux 下Tomcat deploy 阻塞在INFO: Deploying web application directory ….?linux 或者部分unix系统提供随机数设备是/dev/random和/dev/urandom，两个区别是，random安全性高， 生成随机数时间间隔有点长，jdk默认random. 修改$JAVA_HOME/jre/lib/security/java.security文件，替换securerandom.source=file:/dev/random/为secureradom.source=file:/dev/./urandom]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建全教程（一）]]></title>
    <url>%2F2018%2F05%2F10%2Fhexo_1%2F</url>
    <content type="text"><![CDATA[引言 心血来潮，搭建个博客玩玩，看了网上很多教程，有些很全面，我也是参照大家的基本一气呵成，呈现给大家现在的这个样子，但是迫于好奇心，总想知道那些奇奇怪怪的命令到底是什么？于是有了本系列教程的第一部分。 术语 hexo: 基于nodejs的博客框架 next: hexo 主题 github: 不解释 nodejs: javascript运行环境]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷卡付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%88%B7%E5%8D%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[刷卡支付刷卡支付，是接入渠道商通过pos款台，扫用户支付码的支付场景渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【设备接入】接口，取得对应支付授权码 接入商调用明付平台 【授权码支付】接口，进行支付 如果接入商有退款需求，可根据平台订单号进行【退款】操作 设备接入 接口地址： 沙箱：https://realer.cn/api/payService/{version}/device/checkIn 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 授权码 licenceNo 是 String 4ef234239ioiwejq 刷卡支付接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/userPayCode version 1.0 : 同步请求方式 version 2.0 : 异步请求方式，需要客户端主动发起轮询 参数列表 字段名 变量名 必填 类型 示例值 描述 授权码 serierNo 是 String 4ef234239ioiwejq 支付授权码 token 是 String 扫码所得 金额 amount 是 int 10 单位（分） 订单号 orderNo 是 String 接入商订单号 订单时间 beginTime 是 String 20180509123456 yyyyMMddHHmmss 支付类型 payType 是 String WX_F2F,ALI_F2F,JD_F2F ip ip 是 String 127.0.0.1 收银员编号 cashierNo 是 String 80 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 是 String 签名 sign 是 String 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>刷卡付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态码支付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8A%A8%E6%80%81%E7%A0%81%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[动态码支付动态码支付，是渠道商根据用户订单生成对应支付二维码，用户打开支付宝或者微信扫一扫功能，进行扫码支付。渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【下单】接口，取得对应支付二维码链接和对应平台订单号 接入商同时发起轮询【查询】接口，轮询间隔3~5,轮询5次，如果仍然没有收到支付确认，请重新【下单】刷新二维码，并提示用户重新扫码支付 如果接入商有退款需求，可根据平台订单号进行【退款】操作 注意 暂时不支持支付通知处理 下单生成二维码接口 接口地址： 沙箱：https://realer.cn/api/payService/{version}/unifiedOrder 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 用户ID openId 否 String oG3werwerwer1221 动态码请忽略 接入商订单号 orderNo 否 String 1290012 接入商不传，默认平台订单号 订单金额 amount 是 int 12 单位（分） 订单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss 支付类型 payType 是 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 应用ID appId 否 String wxd678efh567hg6787 时间戳 timeStamp 否 String 20180504123546 随机串 nonceStr 否 String wxd678efh567hg6787fsdfsd2 随机串 数据包 package 否 String prepay_id=wx2017033010242291fcfe0db70013231072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx2017033010242291fcfe0db70013231072 签名方式 signType 否 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 签名 paySign 否 String oG3werwerwer1221 明付平台订单号 tradeNo 是 String P98212781821288121 第三方平台订单 outTradeNo 否 String 4001220181230456245 二维码URL codeUrl 是 String weixin://123.12121 动态码关注字段 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>动态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号支付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[公众号支付公众号支付，是渠道商通过微信公众号中的页面发起的线上支付场景渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【下单】接口，取得对应公众号发起支付的参数列表 接入商调起支付接口，根据支付返回码确认支付状态，如果异常情况下，请调用查询接口确认支付状态 如果接入商有退款需求，可根据平台订单号进行【退款】操作 注意 暂时不支持支付通知处理 下单生成公众号支付参数接口 接口地址： 沙箱：https://realer.cn/api/payService/{version}/unifiedOrder 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 用户ID openId 否 String oG3werwerwer1221 动态码请忽略 接入商订单号 orderNo 否 String 1290012 接入商不传，默认平台订单号 订单金额 amount 是 int 12 单位（分） 订单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss 支付类型 payType 是 String WX_NATIVE WX_PUBLIC IP地址 ip 是 String 127.0.0.1 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 应用ID appId 否 String wxd678efh567hg6787 时间戳 timeStamp 否 String 20180504123546 随机串 nonceStr 否 String wxd678efh567hg6787fsdfsd2 随机串 数据包 package 否 String prepay_id=wx2017033010242291fcfe0db70013231072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx2017033010242291fcfe0db70013231072 签名方式 signType 否 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 签名 paySign 否 String oG3werwerwer1221 明付平台订单号 tradeNo 是 String P98212781821288121 第三方平台订单 outTradeNo 否 String 4001220181230456245 二维码URL codeUrl 是 String weixin://123.12121 动态码关注字段 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>动态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URemoteSdk接口文档]]></title>
    <url>%2F2017%2F05%2F09%2Furemote_1%2F</url>
    <content type="text"><![CDATA[文档修订记录： 日期 版本 说明 作者 2017-05-22 1.0 uremotesdk 接口文档 张海亮 2017-07-03 1.0 增加listener,callback接口说明 张海亮 2017-07-05 1.0 增加播控接口说明 张海亮 1 文档说明1.1 功能描述URemoteSdk 是盛世辉科技有限公司提供得一套针对电视盒子和盛世辉遥控器进行网络自定义指令通信方案。第三方盒子APP通过该sdk得接入，可以很放便的通过遥控器操控盒子，实现一些传统遥控器不可有的一些用户操作体验。 1.2 阅读对象本文档面向电视盒子三方APP开发人员、编程人员及测试人员。该人员需要具备一定的Android开发能力。 1.3 术语 名词 解释 URemoteSdk APP层和URemoteService交互API,URemoteSdk会针对遥控器和盒子两端分别给出API接入说明，下文中如无特殊说明，C_URemoteSdk代指遥控端接入API，S_URemoteSdk代值盒子端接入API URemoteService 开发人员只需了解该服务在整个框架中得位置及意义，同理，如无特殊说明，C_URemoteService代指遥控端服务，S_URemoteService代值盒子端服务 请求 通过AIDL/PROTOBUF协议把数据发送给接收方的过程。 通知 一般指盒子端主动推送给遥控器端得消息类型，比如当前处于什么模式（重绘，镜像，还是异步） 返回 遥控端发送操控指令给盒子有两种接入模式，同步或者异步，具体下文会具体描述 心跳 开发人员只做了解，具体代值遥控和盒子通讯机制 2 应用场景及接入流程系统架构： 2.1 重绘同屏应用场景介绍：适用于盒子三方APP开发商，需要借助盒子定制的盛世辉触控遥控器提高应用或者游戏在盒子上的可操作和便利性得需求。 l 场景：用户选择盛世辉遥控器打开电视盒子进入对应APP后，通过对遥控器的点击，触摸，滑动等操作来控制盒子。 l 系统交互时序图 l 具体流程： 用户打开同屏APP，选择某个页面节点。 用户对该节点进行点击或者滑动等操作，封装为具体通信协议发送给盒子。 盒子收到消息同步或者异步返回，同时自己执行对应指令响应。 盒子响应对应指令，进行页面跳转 遥控器响应回传指令，进行页面跳转。 2.2 镜像同屏略 3 接口规范URemoteSdk两类通讯机制，一是websocket，二是AIDL,通讯协议统一用Protobuf. 上层APP和service交互，即URemoteSdk是AIDL。C_URemoteService与S_URemoteService交互是webSocket. Protobuf接口规范如下： 123456789message Envelope &#123; optional uint32 id = 1; required MessageType type = 2; required bytes message = 3;&#125; 1）id 指令消息id，可选参数，一般用于接口异步返回标识。 2）MessageType 指令消息类型，支持自定义，目前支持消息类型： 系统内置消息 12345678910111213141516171819202122232425262728293031323334353637383940414243enum MessageType &#123; EVENT_KEY = 1; EVENT_TOUCH = 2; NOTIFY_STATE = 3; GET_PROCESS = 4; GET_APP = 5; GET_VERSION = 6; GET_DISPLAY = 7; GET_PROPERTIES = 8; GET_SERVER = 9; EVENT_CLICK = 10; EVENT_PLAYER = 11; EVENT_CHANNEL = 12; NOTIFY_PLAYER = 13; EVENT_HOME = 14; EVENT_MESSAGE = 15; EVENT_DIFF = 16; EVENT_DESTORY = 17; EVENT_VOLUME = 18; EVENT_AD = 19; EVENT_GENSOR = 20;&#125; 自定义消息统一用EVENT_MESSAGE。 3）message 具体消息体 以上定义可参照wire.proto或者message.proto 4 接口安全规范略 5 参数类型定义5.1 EVENT_TOUCH-触摸消息 参数名称 参数编码 参数类型 描述 触摸类型 action int32 触摸X点 x float 触摸Y点 y float 5.2 EVENT_KEY-按键消息 参数名称 参数编码 参数类型 描述 事件类型 KeyEvent enum 0,DOWN,1,UP,2.PRESS 按键码 keyCode int32 5.3 EVENT_VOLUME-声音事件（之后重构优化） 参数名称 参数编码 参数类型 描述 音量类型 volumeType enum UP,上行音量 DOWN,下行音量 5.4 GET_APP 获取当前栈顶activity 参数名称 参数编码 参数类型 描述 5.5 EVENT_DESOTRY-Activity关闭 参数名称 参数编码 参数类型 描述 包名 packageName String 应用包名 Activity名称 acitivityName String 应用activity名称 5.6 GET_PROPERITES获取盒子相关属性 参数名称 参数编码 参数类型 描述 属性key name String CA,MAC,DEVICEID 属性value value String 属性值 5.7 GET_VERSION 版本同步暂无使用 5.8 GET_SERVER 设备发现 参数名称 参数编码 参数类型 描述 设备ip ip String 设备ip 5.9 EVENT_HOME HOME处理5.10 EVENT_MESSAGE 自定义通道上层app，自定义通信消息类型 5.11 EVENT_GSENSOR sensor信息 参数名称 参数编码 参数类型 描述 Sensor values values float Sensor values Sensor 容量 accuracy int Sensor 容量 Sensor 时间戳 timestamp long Sensor 时间戳 Sensor sensor Sersor 具体定义参照代码 //TODO播控消息已挪至app层自定义，如需参考，请黄海添加 //TODO其它如广告等后增加的消息类型，请相关开发人员添加 1 URemoteSdk接入1.1.1 遥控端接入流程URemoteSdk目前是作为Andorid第三方依赖工程接入的，之后可能只提供AAR包的方式。本样例只提供Android-studio作为IDE的接入方式，其余IDE类同。 1）工程导入URemoteSdk 配置文件： build.gradle: 添加 12345dependencies &#123; compile project(&apos;:uremotesdk&apos;)&#125; setting.gradle：添加 1include &apos;:app&apos;, &apos;:uremotesdk&apos; 以上内容添加依赖库后，一般都会自动添加。 2）URemoteSdk 初始化 接入SDK的APP，在对应Application中进行初始化： 1URemoteSdk.getInstance().init(URemoteConfig.createDefault(this)); init参数可以自定义，具体请参考相应代码。 3）具体通讯指令支持自定义，与业务相关的具体通讯指令自定义处理，这里提供样例如下： 自定义指令添加位置建议如下： 消息定义参照如下：message.proto OnPageRequest:业务场景ViewPager切换分页指令。 4）接口请求： 123456789Wire.Envelope envelope = Wire.Envelope.newBuilder().setType(Wire.MessageType.EVENT_MESSAGE) .setId(MainIDs.ID_PAGE) .setMessage(com.realer.service.proto.Message.OnPageRequest.newBuilder() .setIndex(indexRadioButton.getIndex()).build().toByteString()).build();URemoteSdk.getInstance().getAgent().onMessage(envelope,null); 自定义消息方法说明： URemoteSdk.getInstance().getAgent().onMessage(Wire.Envelope envelope,OnMessageListener listener) 参数说明： envelope:具体指令消息内容，参照上文提到的protobuf定义。 listener:是否需要回调同步处理，不需要可以传NULL. 5)遥控器和盒子连接状态监听 如果不做特殊处理，采用默认UI交互，APP 抽象基础Activity继承RemoteActivity或者RemoteFragmentActivity. 如果自己处理，监听，更新自定义UI: 动态注册广播： 1234567receiver = new RemoteReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(URemoteState.ACTION_STATE_CHANGE);registerReceiver(receiver,intentFilter); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class RemoteReceiver extends BroadcastReceiver &#123; private static final String TAG = &quot;RemoteReceiver&quot;; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if(action.equals(URemoteState.ACTION_STATE_CHANGE))&#123; int state = intent.getIntExtra(URemoteState.EXTRA_STATE,-1); String info = intent.getStringExtra(URemoteState.EXTRA_INFO); Log.d(TAG,&quot;state&quot; + state); switch (state)&#123; case URemoteState.STATE_CONNECTED: PromptDialog.close(); break; case URemoteState.STATE_CONNECTING: PromptDialog.show(RemoteActivity.this,info,false,null); PromptDialog.hideBottom(); break; case URemoteState.STATE_DISCONNECTED: PromptDialog.show(RemoteActivity.this,info,false,null); PromptDialog.showBottom(); break; &#125; &#125; &#125;&#125; URemoteState: STATE_CONNECTED:已连接 STATE_CONNECTING:连接中 STATE_DISCONNECTED:已断开 6）右上角悬浮菜单 同5，如果采用默认集成，集成方式如下： 对应要显示得Activity中添加： 123456789101112131415161718192021@Overrideprotected void onResume() &#123; super.onResume(); URemoteSdk.getInstance().showMenu();&#125;@Overrideprotected void onPause() &#123; super.onPause(); URemoteSdk.getInstance().hideMenu();&#125; 注意：以上悬浮菜单，连接异常处理，物理返回键，触摸如果整个APP内都集成得话，建议抽象BaseActivity进行处理，另，触摸事件得处理，最好是只传输过程，不传输结果，以免最终结果状态不对应，即ACTION_UP不做指令传递。 具体可参照C_URemoteSdk中的RemoteActivity或者RemoteFragmentActivity. 1.1.2 盒子端接入流程1）工程导入，同遥控端导入方式 2）URemoteSdk初始化，同遥控端初始化方式 3）消息注册监听： 12345678910111213@Overrideprotected void onResume() &#123; super.onResume(); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().registerActivityCallback(messageCallback); &#125;&#125; 12345678910111213@Overrideprotected void onPause() &#123; super.onPause(); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().unregisterActivityCallback(messageCallback); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 /** * 对应消息处理 */private Handler messageHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Wire.Envelope envelope = (Wire.Envelope)msg.obj; try &#123; switch(msg.what)&#123; case MainIDs.ID_PAGE: com.realer.service.proto.Message.OnPageRequest pageRequest = com.realer.service.proto.Message.OnPageRequest.parseFrom(envelope.getMessage()); if(pageRequest != null &amp;&amp; vp != null)&#123; IndexRadioButton indexRadioButton = (IndexRadioButton)title_group.getChildAt(pageRequest.getIndex()); indexRadioButton.setFocusable(true); indexRadioButton.requestFocusFromTouch(); indexRadioButton.requestFocus(); vp.setCurrentItem(pageRequest.getIndex()); &#125; break; default: break; &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;/** * 消息接收 */private IMessageCallback.Stub messageCallback = new IMessageCallback.Stub() &#123; @Override public void onMessage(byte[] msg) throws RemoteException &#123; try &#123; Wire.Envelope envelope = Wire.Envelope.parseFrom(msg); if(envelope.getType() != Wire.MessageType.EVENT_MESSAGE)&#123; Log.d(TAG,&quot;invalid message&quot;); return; &#125; //id区分业务类型，０，默认跳转activity Message handlerMsg = new Message(); handlerMsg.what = envelope.getId(); handlerMsg.obj = envelope; messageHandler.sendMessage(handlerMsg); &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125;&#125;; 4）状态通知，App内所有Activity，onResume要发送推送消息，样例： 123456789101112131415@Overrideprotected void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onActivityNotify&quot;); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().onNotifyState(State.REDRAW); &#125;&#125; State 状态：REDRAW 重绘 ​ MIRROW 镜像 ​ DIFF 异步 注意：以上状态通知，是要求APP必须接入得，消息注册依据自己业务而定，同遥控端接入一样，基础操作仍然可以抽象BaseActivity处理。 具体可参照S_URemoteSdk中的RemoteActivity或者RemoteFragmentActivity. 1.2 接口说明1.2.1 获取CA卡用户遥控端可以通过C_URemoteSdk,获取盒子CA卡信息： 1URemoteSdk.getInstance().getAgent().getProp(Properties.CA) 1.2.2 获取盒子设备ID1URemoteSdk.getInstance().getAgent().getProp(Properties.DEVICEID); 1.2.3 获取盒子设备MAC1URemoteSdk.getInstance().getAgent().getProp(Properties.MAC); 1.2.4 获取盒子状态（重绘，镜像，异步）1URemoteSdk.getInstance().getAgent().getState() State 状态：REDRAW 重绘 ​ MIRROW 镜像 ​ DIFF 异步 1.2.5 获取盒子音量1URemoteSdk.getInstance().getAgent().getVolume() 1.2.6 物理Key事件1URemoteSdk.getInstance().getAgent().onKeyEvent(KeyEvent.KEYCODE_BACK, com.realer.remote.client.protocol.KeyEvent.UP); 1.2.7 物理Touch事件1URemoteSdk.getInstance().getAgent().onTouchEvent(motionEvent.getAction(), x, y); 1.2.8 直播频道换台(不建议使用了，可以自定义消息处理）1URemoteSdk.getInstance().getAgent().onChannelChange(&quot;1000001&quot;); 1.2.9 播控相关事件//TODO ，已挪至上层app，走自定义消息通道，如需参考，请黄海添加 1.2.10 server端callback回调IHomeCallback: home 按键处理 IADCallback: 广告事件处理 IMessageCallback 自定义事件回调 IChannelCallback 频道切换回调 IPlayerCallabck 播控回调 具体注册，和注销请参照具体sdk代码 1.2.11 client端ListenOnAppListen 栈顶app OnMessageListen 消息listen OnMiniCapListen 镜像listen OnURemoteListen 设备发现listen OnPlayerListen 播控listen 具体注册，和注销请参照具体sdk代码 1.2.12 自定义通道1client 主动消息发送通用接口: OnMessage void onEvent(final byte[] message); server 主动推送消息通用接口: OnNotify void onNotify(final byte[] notify); 注：像瀑布流，ListView,GridView,ScrollView等这些滑动控件，建议实现监听滑动跟踪X,Y信息给到盒子端通过自定义消息处理测试下。目前像触摸，key事件 是在service里通过instrument 底层注入得方式，样例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private class EventWorker extends Thread &#123; @Override public void run() &#123; while (!isInterrupted()) &#123; try &#123; Wire.TouchEventRequest touchEventRequest = eventMsgs.take(); if (touchEventRequest != null) &#123; final float touchX = touchEventRequest.getX() * Constants.SERVER_WIDTH / Constants.CLIENT_HEIGHT; final float touchY = touchEventRequest.getY() * Constants.SERVER_HEIGHT / Constants.CLIENT_WIDTH; Log.d(TAG, &quot;input--x&quot; + touchX + &quot;--y--&quot; + touchY); instrumentation.sendPointerSync( MotionEvent.obtain( SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), touchEventRequest.getAction(), touchX, touchY, 0)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125; &#125; 具体那种方案更优，需后期测试。 1.3 ProtoBuf接入说明Probobuf类似JSON得数据通讯协议，效率接近于二进制流，比JSON效率高很多。 Android-Studio 接入方式： app的build.gradle配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293apply plugin: &apos;com.android.application&apos;apply plugin: &apos;com.google.protobuf&apos; //protobuf插件buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; //添加依赖 classpath &apos;com.google.protobuf:protobuf-gradle-plugin:0.8.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;android &#123; .......... //此处省略基础配置 sourceSets &#123; main &#123; java &#123; srcDir &apos;src/main/java&apos; &#125; proto &#123; //指定probuf文件位置 srcDir &apos;src/main/proto&apos; &#125; &#125; &#125;&#125;protobuf &#123; //protobuf插件编译任务 protoc &#123; artifact = &apos;com.google.protobuf:protoc:3.1.0&apos; &#125; generateProtoTasks &#123; all().each &#123; task -&gt; task.builtins &#123; remove java &#125; task.builtins &#123; java &#123; &apos;src/main/java&apos; &#125; // Add cpp output without any option. // DO NOT omit the braces if you want this builtin to be added. cpp &#123;&#125; &#125; &#125; &#125;&#125; 可参照URemoteSdk build.gradle配置 1.4 URemoteSdk 调试及安装URemoteSdk ，同时支持插件和独立APP的调试，三方APP在遥控器端最终是作为插件运行的。但是插件得方式不利于开发人员调试，所以该SDK同时支持 独立APP调试运行。 前置条件： C_URemoteService.apk 遥控器端Service。 adb push C_URemoteService.apk /system/app 重启遥控器 S_URemoteService.apk 盒子端Service。 adb push S_URemoteService.apk /system/app 重启盒子 1）独立APP调试（独立APP只做调试使用，不做最终安装部署） 通过6.1.1，6.1.2流程接入URemoteSdk后，直接安装或者adb push 都可以，app在data分区还是system分区都可以 2）插件调试，安装 通过6.1.1，6.1.2流程接入URemoteSdk后， adb push 对应APP到sdcard分区根目录。具体名称要和插件HOST程序商议协定。 以上调试和安装都是指双端APK包。 参考样例c_setting 工程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URemoteSdk 开发文档]]></title>
    <url>%2F2017%2F05%2F09%2Furemote%2F</url>
    <content type="text"><![CDATA[目录1 文档说明功能描述URemote是盛世辉科技有限公司自主研发的一套用于智能遥控终端和电视盒子进行实时通信的整体解决方案，URemote核心部分即URemoteService将在本文档中做详细说明，对于三方app厂商，URemote 是作为开放平台以URemoteSdk的方式，提供给其进行即成，二次开发。URemoteSdk介绍详见： URemoteSdk接口文档_V1.0.doc 阅读对象本文档面向盛世辉内部研发经理，研发工程师。该人员需要具备一定的Android开发能力，只允许在公司内部流转。 术语 名词 解释 URemoteSdk APP层和URemoteService交互API,URemoteSdk会针对遥控器和盒子两端分别给出API接入说明，下文中如无特殊说明，C_URemoteSdk代指遥控端接入API，S_URemoteSdk代值盒子端接入API URemoteService 开发人员只需了解该服务在整个框架中得位置及意义，同理，如无特殊说明，C_URemoteService代指遥控端服务，S_URemoteService代指盒子端服务 请求 通过AIDL/PROTOBUF协议把数据发送给接收方的过程。 通知 一般指盒子端主动推送给遥控器端得消息类型，比如当前处于什么模式（重绘，镜像，还是异步） 返回 遥控端发送操控指令给盒子有两种接入模式，同步或者异步，具体下文会具体描述 心跳 开发人员只做了解，具体代值遥控和盒子通讯机制 URemote整体架构及URemoteService系统架构及历史演进： 以上架构图是产品初始设计，可以看到，目前最终实现基本未脱离此结构设计，而实际变动部分会在以下内容中说明缘由，框架中，RemoteService是该架构中的核心部分，向上以sdk的方式，给应用层app提供接入指南，向下以本地库为依赖。 RemoteService：提供重绘服务(EventService)，镜像服务(ScreenService)，以及同屏基础设置， 具体名称以实际代码为准。目前代码实现层面上，RemoteService，只提供了对应服务，没有提供对应的设置页面，之后应该在这方面有所补充，例如，提供镜像参数的设置，服务端口的设置等。 通信原本定义基于TCP的socket形式进行，目前是采用开源工程AndroidAsync，具体请参考： https://github.com/koush/AndroidAsync以websocket形式实现，产品原定义的核心的touch消息，镜像协议，是想以so库的形式，这个可能是我们平台作为产品形式，最后从性能，稳定性等方面最终实现的交互方式（参考资料： https://openstf.io/） 目前产品架构： 图中，镜像部分应该是直接和盒子uremoteservice进行通信，这里没有画出跨层通信的交互。镜像部分具体请徐工补充完整。App层和service通过提供的api进行通信，通信方式aidl. Service之间通过websocket通信，通信协议protobuf。 URemoteServiceURemoteService 中的模块（客户端和服务端基本一样，这里只介绍相对复杂一点的遥控客户端，具体差异请参考源代码） WatchDog watchdog 的实现是基于alarm机制，定时监测服务是否存活，主要实现功能uremoteservice保活，android里保活机制有很多种： 有系统权限，内置rom，可以init启动，自动保活 alarm机制，类似看门狗实现 双service互保 我们版本目前采用第二种，之后可以根据我们产品特点进行调整。 websocket： 采用开源AndroidAsync，具体请参考上文提到的参考链接。重绘端口：6059,镜像端口：6060 protobuf: 具体请参考另一篇关于uremoteSdk的介绍 heartbeat: 心跳包，按照AndroidAsync官网建议，采用tcp ping 机制发送固定心跳字断 coreservice 向上提供aidl接口，水平service通信提供websocket接口路由 http 新增协议，主要提供一些同步查询接口，具体请黄海，志臣在uremoteSdk中补充 设备发现 结构图中，遗漏了设备发现功能，设备发现通过服务器发送组播，客户端扫描发送udp包建立握手，获取盒子IP.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
