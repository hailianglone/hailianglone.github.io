<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2018%2F05%2F13%2Fresume%2F</url>
    <content type="text"><![CDATA[联系方式 手机：13263369194 邮箱：hailianglone@gmail.com,hailianglong@126.com QQ: 317824594 简历线上版：http://yuhengzhang.cn/2018/05/13/resume，密钥：zhanghl 个人信息 张海亮／男／1985 本科／河北大学（数学与计算机系） 工作年限： 9年 工作经历：1年J2ME方向，4年Android方向，4年JavaWeb方向 技术博客： http://yuhengzhang.cn (很汗颜，刚搭建) GitHub： http://github.com/hailianglone 期望职位 ：web高级研发工程师，系统架构师 期望薪资：税前月薪35K，可面议，期权或股份特别的可例外 期望城市：北京 工作经历北京新锐友信软件技术有限公司（2013年5月～至今）职位：技术合伙人 产品聚合支付（明付平台）(web)明付平台是集支付宝，微信，京东，翼支付，银联二维码等平台之上的三方支付服务商平台，旨在帮助企业迅速便捷的接入相关支付的开放平台，目前SDK已开放的支付包含： 一码付（商户提供一个二维码付款码，同时支持用户微信和支付宝主扫发起的支付） 刷卡付 （用户出示手机App钱包付款码，由商户主扫发起的支付，目前支持微信，支付宝，京东，翼支付，银联二维码，和包支付） 微信公众号支付 微信小程序支付 微信动态码支付 目前已接入商户列表： 北京华联综超（对应门店62家） 柏溪商贸 萌优集 华联西安skp (马上接入) 该平台服务端架构设计，研发，部署运维，基本是本人一人负责，目前日流水600w，订单量100w单，SDK还未已开放方式发布。 小咖停车(web and android)小咖停车是基于简单IOT蓝牙通信技术，通过App和智能地锁的配合，用来解决停车难的问题，产品本来定位的写字楼和附近小区的错时停车，目前由于小区物业，居委会等等一系列问题，正在尝试海外日本市场，国内已接入小区和写字楼： 牡丹园西里 知春路荣上居 有研院 首钢停运（大洋路市场，暂未对外开放） 日本福冈（洽谈中） 该平台服务端和Android客户端设计与研发基本由本人一人负责。 下载链接：http://www.360park.com.cn 零钱彩(web)零钱彩是彩票和零售的一种结合创新，目前已在华联部分超市试运营，由于本产品主属兄弟公司，业务和模式上暂处保密状态，不便多说。 本平台第一版本服务器端是本人一人进行设计和研发，目前该产品已获PreA融资。 小程序版： 项目北京华联是我们主要的客户，目前为华联提供的服务有： pos 收银 posserver 收银服务端 crm 支付 公众号 自助购 北京华联CRM系统(web)北京华联crm系统是针对华联信息系统整个闭环系统中关于会员系统的解决方案，零售行业的会员系统是所有crm系统中最为复杂的，已实现主要功能列表如下： 组织机构和门店管理 员工管理，菜单管理和角色权限管理 基础设置（俱乐部设置，积分权益设置，销售权益设置，支付权益设置） 积分返利，积分抵现，积分返礼 促销管理（折扣促销，优惠券促销，积分促销） 会员卡服务台 办卡自动化处理 简单审批 报表系统 该系统研发团队3人，本人主要负责项目跟踪和实施，以及对接基础设置模块和促销管理模块，为pos系统提供crm核心api接口实现。 北京华联公众号系统（web)华联公众号系统是华联为了集中管理各个地区公众号营销以及电子会员管理而定制的公众号系统开发，系统功能列表： 粉丝自动划分地区 分地区设置海报，本地特色，热销榜单，自由品牌，每月上新 电子会员 会员课堂 BHG服务（电子发票，会员权益，附近门店，意见反馈，常见问题） 分地区招聘设置 该系统需求和服务端设计，研发及部署运维，本人一人负责。 国安盒子触控遥控器(android)本系统是另一个初创团队的项目，一期主要本人负责和带队，遥控器广州地区一小批量量产，该遥控器是基于android原生系统定制，不同于目前市场上的智能遥控器，触控遥控器的本质是反向了小屏投大屏的模式，它是把电视屏幕投到遥控器屏幕附带红外控制功能，投屏模式分为镜像同屏和重绘同屏模式，系统架构为了后来要做平台的需求，架构设计如下： 其它项目 优驾行（陕西优驾行）(android) 掌中宝 （圣元国际）（web and android) 国网直升机调度系统（国家电网）（web) 烤圈（海尔）（android) 黄金60s（外包，湖南卫视）（android) 宝宝讲故事（外包，金和）（android) 微视（外包，cctv)（android) 中科创达科技股份有限公司（2011年9月～2013年5月）职位：subleader 展讯8810，6810等项目（抱歉有些实在记不清楚了）本人主要担任app小组subleader,团队4～6人，主负责模块： Contacts （联系人） Launcher（主界面） LockScreen （锁屏） Setting （设置） QuickSearchBox（搜索） InputMethod（输入法） 北京捷通华声（2009年9月～2011年9月）职位：研发工程师 天行输入法主打手写输入，支持全屏手写，窗口书写，字体支持颜色设置，大小设置，简繁体设置以及毛笔等格式设置，以及更牛逼的行识别。当然手写识别和语音识别是公司核心，该部分都在公司研发总监手上，我们是so库方式集成接入。 其它项目J2ME 相关，诺基亚N71（塞班系统）的时代了。 开源项目和作品初创团队，你懂得，除了工作基本都没有思考的时间，只是短暂参与过iBase4j 的项目，除了提了问题和提供swagger-ui支持，基本没有参与过什么。 https://gitee.com/iBase4J/iBase4J 注：以上所有web项目基本架构都是： spring/springmvc+mybatis+mysql/oracle+redis+shiro+swagger+fastdfs+nginx+tomcat 数据库支持读写分离 nginx做反向代理和负载均衡 swagger在线接口文档输出 shiro 权限管理 redis 缓存服务器和session共享 shardingjdbc/mycat 两种分库分表方案（暂时没有用到哦） fastdfs 文件和图片服务器 技能清单 Web开发：spring/springmvc/mybatis/hibernate/jpa/mysql/oracle/sqlite/redis（熟悉），structs/springboot/ejb/python/nosql/nodejs（了解） Web前端：jsp（熟悉），jquery/vue/argularjs（了解），react（知道有） 版本管理，文档和自动化部署工具：/cvs/svn/git/jenkins/redmine（熟悉），docker（了解） 包管理：/ant/maven/gradle（熟悉）, npm/yarn（前端了解） 单元测试：junit 文件存储：/ftp/fastdfs （熟悉） Linux 常用命令 Web容器：/nginx/tomcat（熟悉），weblogic/jetty （了解） Android：app/framework 云和开放平台：阿里云/腾讯云/ecs/oss/rds，七牛云，亚马逊云（马上要），/微信支付平台/微信公众平台/微信开放平台/蚂蚁金服开放平台／微博开放平台／腾讯开放平台／科大讯飞语音云／容联云短信／友盟统计／极光推送／环信通信／TestIn测试平台／银联开放平台／京东金融开放平台／电信翼支付开放平台／，openfire(了解) 分布式与大数据：dubbo/zookeeper/hadoop/spark/storm等（本人只是略知，毕竟目前实际项目未用到） 常用传输数据结构：/xml/json/protobuf 注：初创团队兼任scm和运维部署，负责/redmine/gitlab/jenkins/svn等服务搭建，以及产品和项目发布。 致谢感谢您花时间阅读我的简历，期待有机会与您一起共事。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2018%2F05%2F13%2Fkownledge%2F</url>
    <content type="text"><![CDATA[mac 拼音选择框不见？打开 Terminal （命令行），输入下面，回车即可。 1pkill -f SCIM.app Linux 下Tomcat deploy 阻塞在INFO: Deploying web application directory ….?linux 或者部分unix系统提供随机数设备是/dev/random和/dev/urandom，两个区别是，random安全性高， 生成随机数时间间隔有点长，jdk默认random. 修改$JAVA_HOME/jre/lib/security/java.security文件，替换securerandom.source=file:/dev/random/为secureradom.source=file:/dev/./urandom]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建全教程（一）]]></title>
    <url>%2F2018%2F05%2F10%2Fhexo_1%2F</url>
    <content type="text"><![CDATA[引言 心血来潮，搭建个博客玩玩，看了网上很多教程，有些很全面，我也是参照大家的基本一气呵成，呈现给大家现在的这个样子，但是迫于好奇心，总想知道那些奇奇怪怪的命令到底是什么？于是有了本系列教程的第一部分。 术语 hexo: 基于nodejs的博客框架 next: hexo 主题 github: 不解释 nodejs: javascript运行环境]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号支付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[公众号支付公众号支付，是渠道商通过微信公众号中的页面发起的线上支付场景渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【下单】接口，取得对应公众号发起支付的参数列表 接入商调起支付接口，根据支付返回码确认支付状态，如果异常情况下，请调用查询接口确认支付状态 如果接入商有退款需求，可根据平台订单号进行【退款】操作 注意 暂时不支持支付通知处理 下单生成公众号支付参数接口 接口地址： 沙箱：https://realer.cn/api/payService/{version}/unifiedOrder 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 用户ID openId 否 String oG3werwerwer1221 动态码请忽略 接入商订单号 orderNo 否 String 1290012 接入商不传，默认平台订单号 订单金额 amount 是 int 12 单位（分） 订单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss 支付类型 payType 是 String WX_NATIVE WX_PUBLIC IP地址 ip 是 String 127.0.0.1 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 应用ID appId 否 String wxd678efh567hg6787 时间戳 timeStamp 否 String 20180504123546 随机串 nonceStr 否 String wxd678efh567hg6787fsdfsd2 随机串 数据包 package 否 String prepay_id=wx2017033010242291fcfe0db70013231072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx2017033010242291fcfe0db70013231072 签名方式 signType 否 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 签名 paySign 否 String oG3werwerwer1221 明付平台订单号 tradeNo 是 String P98212781821288121 第三方平台订单 outTradeNo 否 String 4001220181230456245 二维码URL codeUrl 是 String weixin://123.12121 动态码关注字段 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>动态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷卡付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%88%B7%E5%8D%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[刷卡支付刷卡支付，是接入渠道商通过pos款台，扫用户支付码的支付场景渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【设备接入】接口，取得对应支付授权码 接入商调用明付平台 【授权码支付】接口，进行支付 如果接入商有退款需求，可根据平台订单号进行【退款】操作 设备接入 接口地址： 沙箱：https://realer.cn/api/payService/{version}/device/checkIn 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 授权码 licenceNo 是 String 4ef234239ioiwejq 刷卡支付接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/userPayCode version 1.0 : 同步请求方式 version 2.0 : 异步请求方式，需要客户端主动发起轮询 参数列表 字段名 变量名 必填 类型 示例值 描述 授权码 serierNo 是 String 4ef234239ioiwejq 支付授权码 token 是 String 扫码所得 金额 amount 是 int 10 单位（分） 订单号 orderNo 是 String 接入商订单号 订单时间 beginTime 是 String 20180509123456 yyyyMMddHHmmss 支付类型 payType 是 String WX_F2F,ALI_F2F,JD_F2F ip ip 是 String 127.0.0.1 收银员编号 cashierNo 是 String 80 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 是 String 签名 sign 是 String 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>刷卡付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态码支付]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8A%A8%E6%80%81%E7%A0%81%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[动态码支付动态码支付，是渠道商根据用户订单生成对应支付二维码，用户打开支付宝或者微信扫一扫功能，进行扫码支付。渠道接入商接入流程： 明付平台分配给渠道商，对应的渠道号，虚拟门店号，款台号（门店号，款台号根据接入商对账要求和接入商一起定义规则） 接入商调用明付平台【下单】接口，取得对应支付二维码链接和对应平台订单号 接入商同时发起轮询【查询】接口，轮询间隔3~5,轮询5次，如果仍然没有收到支付确认，请重新【下单】刷新二维码，并提示用户重新扫码支付 如果接入商有退款需求，可根据平台订单号进行【退款】操作 注意 暂时不支持支付通知处理 下单生成二维码接口 接口地址： 沙箱：https://realer.cn/api/payService/{version}/unifiedOrder 默认版本号 1.0 参数列表 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 10% ; } table th:nth-of-type(3){ width: 10%; } table th:nth-of-type(4){ width: 10%; } table th:nth-of-type(5){ width: 30%; } table th:nth-of-type(6){ width: 30%; } 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 用户ID openId 否 String oG3werwerwer1221 动态码请忽略 接入商订单号 orderNo 否 String 1290012 接入商不传，默认平台订单号 订单金额 amount 是 int 12 单位（分） 订单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss 支付类型 payType 是 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 币种 currency 否 String CNY 商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 应用ID appId 否 String wxd678efh567hg6787 时间戳 timeStamp 否 String 20180504123546 随机串 nonceStr 否 String wxd678efh567hg6787fsdfsd2 随机串 数据包 package 否 String prepay_id=wx2017033010242291fcfe0db70013231072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx2017033010242291fcfe0db70013231072 签名方式 signType 否 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 签名 paySign 否 String oG3werwerwer1221 明付平台订单号 tradeNo 是 String P98212781821288121 第三方平台订单 outTradeNo 否 String 4001220181230456245 二维码URL codeUrl 是 String weixin://123.12121 动态码关注字段 订单查询接口仅仅支持明付订单号查询 接口地址： 沙箱： https://realer.cn/api/payService/{version}/tradePayQuery 默认版本号 1.0 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 接入商订单号 orderNo 否 String oG3werwerwer1221 明付商户订单号 tradeNo 是 String 1290012 orderNo ,tradeNo 二选一，优先tradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121 订单退款接口 接口地址： 沙箱： https://realer.cn/api/payService/{version}/refundment 默认版本号 1.0 ，退货要求必须传refundNo,因为可以一票多退，防止重退，该字段接入商户必须保证唯一。参考生成规则orderNo-上笔退款平台订单号 参数列表 字段名 变量名 必填 类型 示例值 描述 渠道号 channelId 是 String 1000 门店编号 storeNo 是 String 100085 设备编号 posNo 是 String 100 动态码设备列表区间100~119 收银员编号 cashierNo 否 String 02 许可列号 serierNo 否 String fe2323df999 动态码请忽略 退款金额 amount 是 int 12 单位（分） 接入商原订单号 oriOrderNo 否 String 201804211320 接入商退款订单号 orderNo 否 String 201804211320 接入商不传，默认平台退单号 接入商退款唯一订单号 refundNo 是 String 1712010027-P03936456117297483776 接入商唯一，退单号 明付商户原订单号 TradeNo 是 String P982127777712 oriOrderNo ,oriTradeNo 二选一，oriTradeNo 支付类型 payType 否 String WX_NATIVE WX_NATIVE(微信）,ALI_NATIVE（支付宝） 退货商品详情 goodsDetail 否 String [{“goodsId”:”id0”,”goodsName“:”iname”,”price”:3,”quantity”:2},{“goodsId”:”id1”,”goodsName“:”iname”,”price”:3,”quantity”:2}] 退单时间 beginTime 是 String 20180504123546 yyyyMMddHHmmss IP地址 ip 是 String 127.0.0.1 备注 comment 否 String 签名 sign 是 String 非空参数按ASCII 排序，末尾增加明付平台分配的KEY 返回结果 字段名 变量名 必填 类型 示例值 描述 原单支付金额 oriPayMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时，原单剩余可退金额 oriSurplusMoney 否 int 1000 单位（分），只有查询退款时，该值才有意义 退款时 ，原单接入商订单号 oriOrderNo 否 String 201804211320 退款时，原单明付平台流水号 oriTradeSerial 否 String P901283232343434 退款时，原单三方平台流水号 oriThirdTradeNo 否 String 40092182888812121 总支付金额 needPayMoney 是 int 1000 终端发起的待付金额 needPayMoney=payMoney+thirdDiscountMoney+discountMoney+merchantDiscountMoney 用户支付金额 payMoney 是 int 1000 用户支付金额 第三方优惠金额 thirdDiscountMoney 否 int 1000 第三方优惠金额 明付平台优惠金额 discountMoney 否 int 1000 明付平台优惠金额 接入商优惠金额 merchantDiscountMoney 否 int 1000 暂不支持 交易时间 tradeTime 是 String 20180504123546 yyyyMMddHHmmss 接入商订单号 orderNo 否 String 201804211320 明付平台流水号 tradeSerial 否 String P901283232343434 三方平台流水号 thirdTradeNo 否 String 40092182888812121]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>支付</tag>
        <tag>动态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URemoteSdk 开发文档]]></title>
    <url>%2F2017%2F05%2F09%2Furemote%2F</url>
    <content type="text"><![CDATA[目录1 文档说明功能描述URemote是盛世辉科技有限公司自主研发的一套用于智能遥控终端和电视盒子进行实时通信的整体解决方案，URemote核心部分即URemoteService将在本文档中做详细说明，对于三方app厂商，URemote 是作为开放平台以URemoteSdk的方式，提供给其进行即成，二次开发。URemoteSdk介绍详见： URemoteSdk接口文档_V1.0.doc 阅读对象本文档面向盛世辉内部研发经理，研发工程师。该人员需要具备一定的Android开发能力，只允许在公司内部流转。 术语 名词 解释 URemoteSdk APP层和URemoteService交互API,URemoteSdk会针对遥控器和盒子两端分别给出API接入说明，下文中如无特殊说明，C_URemoteSdk代指遥控端接入API，S_URemoteSdk代值盒子端接入API URemoteService 开发人员只需了解该服务在整个框架中得位置及意义，同理，如无特殊说明，C_URemoteService代指遥控端服务，S_URemoteService代指盒子端服务 请求 通过AIDL/PROTOBUF协议把数据发送给接收方的过程。 通知 一般指盒子端主动推送给遥控器端得消息类型，比如当前处于什么模式（重绘，镜像，还是异步） 返回 遥控端发送操控指令给盒子有两种接入模式，同步或者异步，具体下文会具体描述 心跳 开发人员只做了解，具体代值遥控和盒子通讯机制 URemote整体架构及URemoteService系统架构及历史演进： 以上架构图是产品初始设计，可以看到，目前最终实现基本未脱离此结构设计，而实际变动部分会在以下内容中说明缘由，框架中，RemoteService是该架构中的核心部分，向上以sdk的方式，给应用层app提供接入指南，向下以本地库为依赖。 RemoteService：提供重绘服务(EventService)，镜像服务(ScreenService)，以及同屏基础设置， 具体名称以实际代码为准。目前代码实现层面上，RemoteService，只提供了对应服务，没有提供对应的设置页面，之后应该在这方面有所补充，例如，提供镜像参数的设置，服务端口的设置等。 通信原本定义基于TCP的socket形式进行，目前是采用开源工程AndroidAsync，具体请参考： https://github.com/koush/AndroidAsync以websocket形式实现，产品原定义的核心的touch消息，镜像协议，是想以so库的形式，这个可能是我们平台作为产品形式，最后从性能，稳定性等方面最终实现的交互方式（参考资料： https://openstf.io/） 目前产品架构： 图中，镜像部分应该是直接和盒子uremoteservice进行通信，这里没有画出跨层通信的交互。镜像部分具体请徐工补充完整。App层和service通过提供的api进行通信，通信方式aidl. Service之间通过websocket通信，通信协议protobuf。 URemoteServiceURemoteService 中的模块（客户端和服务端基本一样，这里只介绍相对复杂一点的遥控客户端，具体差异请参考源代码） WatchDog watchdog 的实现是基于alarm机制，定时监测服务是否存活，主要实现功能uremoteservice保活，android里保活机制有很多种： 有系统权限，内置rom，可以init启动，自动保活 alarm机制，类似看门狗实现 双service互保 我们版本目前采用第二种，之后可以根据我们产品特点进行调整。 websocket： 采用开源AndroidAsync，具体请参考上文提到的参考链接。重绘端口：6059,镜像端口：6060 protobuf: 具体请参考另一篇关于uremoteSdk的介绍 heartbeat: 心跳包，按照AndroidAsync官网建议，采用tcp ping 机制发送固定心跳字断 coreservice 向上提供aidl接口，水平service通信提供websocket接口路由 http 新增协议，主要提供一些同步查询接口，具体请黄海，志臣在uremoteSdk中补充 设备发现 结构图中，遗漏了设备发现功能，设备发现通过服务器发送组播，客户端扫描发送udp包建立握手，获取盒子IP.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URemoteSdk]]></title>
    <url>%2F2017%2F05%2F09%2Furemote_1%2F</url>
    <content type="text"><![CDATA[URemoteSdk**开发接口** 文档修订记录： 日期 版本 说明 作者 2017-05-22 1.0 uremotesdk 接口文档 张海亮 2017-07-03 1.0 增加listener,callback接口说明 张海亮 2017-07-05 1.0 增加播控接口说明 张海亮 1 文档说明1.1 功能描述URemoteSdk 是盛世辉科技有限公司提供得一套针对电视盒子和盛世辉遥控器进行网络自定义指令通信方案。第三方盒子APP通过该sdk得接入，可以很放便的通过遥控器操控盒子，实现一些传统遥控器不可有的一些用户操作体验。 1.2 阅读对象本文档面向电视盒子三方APP开发人员、编程人员及测试人员。该人员需要具备一定的Android开发能力。 1.3 术语 名词 解释 URemoteSdk APP层和URemoteService交互API,URemoteSdk会针对遥控器和盒子两端分别给出API接入说明，下文中如无特殊说明，C_URemoteSdk代指遥控端接入API，S_URemoteSdk代值盒子端接入API URemoteService 开发人员只需了解该服务在整个框架中得位置及意义，同理，如无特殊说明，C_URemoteService代指遥控端服务，S_URemoteService代值盒子端服务 请求 通过AIDL/PROTOBUF协议把数据发送给接收方的过程。 通知 一般指盒子端主动推送给遥控器端得消息类型，比如当前处于什么模式（重绘，镜像，还是异步） 返回 遥控端发送操控指令给盒子有两种接入模式，同步或者异步，具体下文会具体描述 心跳 开发人员只做了解，具体代值遥控和盒子通讯机制 2 应用场景及接入流程系统架构： 2.1 重绘同屏应用场景介绍：适用于盒子三方APP开发商，需要借助盒子定制的盛世辉触控遥控器提高应用或者游戏在盒子上的可操作和便利性得需求。 l 场景：用户选择盛世辉遥控器打开电视盒子进入对应APP后，通过对遥控器的点击，触摸，滑动等操作来控制盒子。 l 系统交互时序图 l 具体流程： 用户打开同屏APP，选择某个页面节点。 用户对该节点进行点击或者滑动等操作，封装为具体通信协议发送给盒子。 盒子收到消息同步或者异步返回，同时自己执行对应指令响应。 盒子响应对应指令，进行页面跳转 遥控器响应回传指令，进行页面跳转。 2.2 镜像同屏略 3 接口规范URemoteSdk两类通讯机制，一是websocket，二是AIDL,通讯协议统一用Protobuf. 上层APP和service交互，即URemoteSdk是AIDL。C_URemoteService与S_URemoteService交互是webSocket. Protobuf接口规范如下： 123456789message Envelope &#123; optional uint32 id = 1; required MessageType type = 2; required bytes message = 3;&#125; 1）id 指令消息id，可选参数，一般用于接口异步返回标识。 2）MessageType 指令消息类型，支持自定义，目前支持消息类型： 系统内置消息 12345678910111213141516171819202122232425262728293031323334353637383940414243enum MessageType &#123; EVENT_KEY = 1; EVENT_TOUCH = 2; NOTIFY_STATE = 3; GET_PROCESS = 4; GET_APP = 5; GET_VERSION = 6; GET_DISPLAY = 7; GET_PROPERTIES = 8; GET_SERVER = 9; EVENT_CLICK = 10; EVENT_PLAYER = 11; EVENT_CHANNEL = 12; NOTIFY_PLAYER = 13; EVENT_HOME = 14; EVENT_MESSAGE = 15; EVENT_DIFF = 16; EVENT_DESTORY = 17; EVENT_VOLUME = 18; EVENT_AD = 19; EVENT_GENSOR = 20;&#125; 自定义消息统一用EVENT_MESSAGE。 3）message 具体消息体 以上定义可参照wire.proto或者message.proto 4 接口安全规范略 5 参数类型定义5.1 EVENT_TOUCH-触摸消息 参数名称 参数编码 参数类型 描述 触摸类型 action int32 触摸X点 x float 触摸Y点 y float 5.2 EVENT_KEY-按键消息 参数名称 参数编码 参数类型 描述 事件类型 KeyEvent enum 0,DOWN,1,UP,2.PRESS 按键码 keyCode int32 5.3 EVENT_VOLUME-声音事件（之后重构优化） 参数名称 参数编码 参数类型 描述 音量类型 volumeType enum UP,上行音量 DOWN,下行音量 5.4 GET_APP 获取当前栈顶activity 参数名称 参数编码 参数类型 描述 5.5 EVENT_DESOTRY-Activity关闭 参数名称 参数编码 参数类型 描述 包名 packageName String 应用包名 Activity名称 acitivityName String 应用activity名称 5.6 GET_PROPERITES获取盒子相关属性 参数名称 参数编码 参数类型 描述 属性key name String CA,MAC,DEVICEID 属性value value String 属性值 5.7 GET_VERSION 版本同步暂无使用 5.8 GET_SERVER 设备发现 参数名称 参数编码 参数类型 描述 设备ip ip String 设备ip 5.9 EVENT_HOME HOME处理5.10 EVENT_MESSAGE 自定义通道上层app，自定义通信消息类型 5.11 EVENT_GSENSOR sensor信息 参数名称 参数编码 参数类型 描述 Sensor values values float Sensor values Sensor 容量 accuracy int Sensor 容量 Sensor 时间戳 timestamp long Sensor 时间戳 Sensor sensor Sersor 具体定义参照代码 //TODO播控消息已挪至app层自定义，如需参考，请黄海添加 //TODO其它如广告等后增加的消息类型，请相关开发人员添加 1 URemoteSdk接入1.1.1 遥控端接入流程URemoteSdk目前是作为Andorid第三方依赖工程接入的，之后可能只提供AAR包的方式。本样例只提供Android-studio作为IDE的接入方式，其余IDE类同。 1）工程导入URemoteSdk 配置文件： build.gradle: 添加 12345dependencies &#123; compile project(&apos;:uremotesdk&apos;)&#125; setting.gradle：添加 1include &apos;:app&apos;, &apos;:uremotesdk&apos; 以上内容添加依赖库后，一般都会自动添加。 2）URemoteSdk 初始化 接入SDK的APP，在对应Application中进行初始化： 1URemoteSdk.getInstance().init(URemoteConfig.createDefault(this)); init参数可以自定义，具体请参考相应代码。 3）具体通讯指令支持自定义，与业务相关的具体通讯指令自定义处理，这里提供样例如下： 自定义指令添加位置建议如下： 消息定义参照如下：message.proto OnPageRequest:业务场景ViewPager切换分页指令。 4）接口请求： 123456789Wire.Envelope envelope = Wire.Envelope.newBuilder().setType(Wire.MessageType.EVENT_MESSAGE) .setId(MainIDs.ID_PAGE) .setMessage(com.realer.service.proto.Message.OnPageRequest.newBuilder() .setIndex(indexRadioButton.getIndex()).build().toByteString()).build();URemoteSdk.getInstance().getAgent().onMessage(envelope,null); 自定义消息方法说明： URemoteSdk.getInstance().getAgent().onMessage(Wire.Envelope envelope,OnMessageListener listener) 参数说明： envelope:具体指令消息内容，参照上文提到的protobuf定义。 listener:是否需要回调同步处理，不需要可以传NULL. 5)遥控器和盒子连接状态监听 如果不做特殊处理，采用默认UI交互，APP 抽象基础Activity继承RemoteActivity或者RemoteFragmentActivity. 如果自己处理，监听，更新自定义UI: 动态注册广播： 1234567receiver = new RemoteReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(URemoteState.ACTION_STATE_CHANGE);registerReceiver(receiver,intentFilter); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class RemoteReceiver extends BroadcastReceiver &#123; private static final String TAG = &quot;RemoteReceiver&quot;; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if(action.equals(URemoteState.ACTION_STATE_CHANGE))&#123; int state = intent.getIntExtra(URemoteState.EXTRA_STATE,-1); String info = intent.getStringExtra(URemoteState.EXTRA_INFO); Log.d(TAG,&quot;state&quot; + state); switch (state)&#123; case URemoteState.STATE_CONNECTED: PromptDialog.close(); break; case URemoteState.STATE_CONNECTING: PromptDialog.show(RemoteActivity.this,info,false,null); PromptDialog.hideBottom(); break; case URemoteState.STATE_DISCONNECTED: PromptDialog.show(RemoteActivity.this,info,false,null); PromptDialog.showBottom(); break; &#125; &#125; &#125;&#125; URemoteState: STATE_CONNECTED:已连接 STATE_CONNECTING:连接中 STATE_DISCONNECTED:已断开 6）右上角悬浮菜单 同5，如果采用默认集成，集成方式如下： 对应要显示得Activity中添加： 123456789101112131415161718192021@Overrideprotected void onResume() &#123; super.onResume(); URemoteSdk.getInstance().showMenu();&#125;@Overrideprotected void onPause() &#123; super.onPause(); URemoteSdk.getInstance().hideMenu();&#125; 注意：以上悬浮菜单，连接异常处理，物理返回键，触摸如果整个APP内都集成得话，建议抽象BaseActivity进行处理，另，触摸事件得处理，最好是只传输过程，不传输结果，以免最终结果状态不对应，即ACTION_UP不做指令传递。 具体可参照C_URemoteSdk中的RemoteActivity或者RemoteFragmentActivity. 1.1.2 盒子端接入流程1）工程导入，同遥控端导入方式 2）URemoteSdk初始化，同遥控端初始化方式 3）消息注册监听： 12345678910111213@Overrideprotected void onResume() &#123; super.onResume(); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().registerActivityCallback(messageCallback); &#125;&#125; 12345678910111213@Overrideprotected void onPause() &#123; super.onPause(); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().unregisterActivityCallback(messageCallback); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 /** * 对应消息处理 */private Handler messageHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Wire.Envelope envelope = (Wire.Envelope)msg.obj; try &#123; switch(msg.what)&#123; case MainIDs.ID_PAGE: com.realer.service.proto.Message.OnPageRequest pageRequest = com.realer.service.proto.Message.OnPageRequest.parseFrom(envelope.getMessage()); if(pageRequest != null &amp;&amp; vp != null)&#123; IndexRadioButton indexRadioButton = (IndexRadioButton)title_group.getChildAt(pageRequest.getIndex()); indexRadioButton.setFocusable(true); indexRadioButton.requestFocusFromTouch(); indexRadioButton.requestFocus(); vp.setCurrentItem(pageRequest.getIndex()); &#125; break; default: break; &#125; &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;/** * 消息接收 */private IMessageCallback.Stub messageCallback = new IMessageCallback.Stub() &#123; @Override public void onMessage(byte[] msg) throws RemoteException &#123; try &#123; Wire.Envelope envelope = Wire.Envelope.parseFrom(msg); if(envelope.getType() != Wire.MessageType.EVENT_MESSAGE)&#123; Log.d(TAG,&quot;invalid message&quot;); return; &#125; //id区分业务类型，０，默认跳转activity Message handlerMsg = new Message(); handlerMsg.what = envelope.getId(); handlerMsg.obj = envelope; messageHandler.sendMessage(handlerMsg); &#125; catch (InvalidProtocolBufferException e) &#123; e.printStackTrace(); &#125; &#125;&#125;; 4）状态通知，App内所有Activity，onResume要发送推送消息，样例： 123456789101112131415@Overrideprotected void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onActivityNotify&quot;); if(URemoteSdk.getInstance().getAgent() != null)&#123; URemoteSdk.getInstance().getAgent().onNotifyState(State.REDRAW); &#125;&#125; State 状态：REDRAW 重绘 ​ MIRROW 镜像 ​ DIFF 异步 注意：以上状态通知，是要求APP必须接入得，消息注册依据自己业务而定，同遥控端接入一样，基础操作仍然可以抽象BaseActivity处理。 具体可参照S_URemoteSdk中的RemoteActivity或者RemoteFragmentActivity. 1.2 接口说明1.2.1 获取CA卡用户遥控端可以通过C_URemoteSdk,获取盒子CA卡信息： 1URemoteSdk.getInstance().getAgent().getProp(Properties.CA) 1.2.2 获取盒子设备ID1URemoteSdk.getInstance().getAgent().getProp(Properties.DEVICEID); 1.2.3 获取盒子设备MAC1URemoteSdk.getInstance().getAgent().getProp(Properties.MAC); 1.2.4 获取盒子状态（重绘，镜像，异步）1URemoteSdk.getInstance().getAgent().getState() State 状态：REDRAW 重绘 ​ MIRROW 镜像 ​ DIFF 异步 1.2.5 获取盒子音量1URemoteSdk.getInstance().getAgent().getVolume() 1.2.6 物理Key事件1URemoteSdk.getInstance().getAgent().onKeyEvent(KeyEvent.KEYCODE_BACK, com.realer.remote.client.protocol.KeyEvent.UP); 1.2.7 物理Touch事件1URemoteSdk.getInstance().getAgent().onTouchEvent(motionEvent.getAction(), x, y); 1.2.8 直播频道换台(不建议使用了，可以自定义消息处理）1URemoteSdk.getInstance().getAgent().onChannelChange(&quot;1000001&quot;); 1.2.9 播控相关事件//TODO ，已挪至上层app，走自定义消息通道，如需参考，请黄海添加 1.2.10 server端callback回调IHomeCallback: home 按键处理 IADCallback: 广告事件处理 IMessageCallback 自定义事件回调 IChannelCallback 频道切换回调 IPlayerCallabck 播控回调 具体注册，和注销请参照具体sdk代码 1.2.11 client端ListenOnAppListen 栈顶app OnMessageListen 消息listen OnMiniCapListen 镜像listen OnURemoteListen 设备发现listen OnPlayerListen 播控listen 具体注册，和注销请参照具体sdk代码 1.2.12 自定义通道1client 主动消息发送通用接口: OnMessage void onEvent(final byte[] message); server 主动推送消息通用接口: OnNotify void onNotify(final byte[] notify); 注：像瀑布流，ListView,GridView,ScrollView等这些滑动控件，建议实现监听滑动跟踪X,Y信息给到盒子端通过自定义消息处理测试下。目前像触摸，key事件 是在service里通过instrument 底层注入得方式，样例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private class EventWorker extends Thread &#123; @Override public void run() &#123; while (!isInterrupted()) &#123; try &#123; Wire.TouchEventRequest touchEventRequest = eventMsgs.take(); if (touchEventRequest != null) &#123; final float touchX = touchEventRequest.getX() * Constants.SERVER_WIDTH / Constants.CLIENT_HEIGHT; final float touchY = touchEventRequest.getY() * Constants.SERVER_HEIGHT / Constants.CLIENT_WIDTH; Log.d(TAG, &quot;input--x&quot; + touchX + &quot;--y--&quot; + touchY); instrumentation.sendPointerSync( MotionEvent.obtain( SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), touchEventRequest.getAction(), touchX, touchY, 0)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125; &#125; 具体那种方案更优，需后期测试。 1.3 ProtoBuf接入说明Probobuf类似JSON得数据通讯协议，效率接近于二进制流，比JSON效率高很多。 Android-Studio 接入方式： app的build.gradle配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293apply plugin: &apos;com.android.application&apos;apply plugin: &apos;com.google.protobuf&apos; //protobuf插件buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; //添加依赖 classpath &apos;com.google.protobuf:protobuf-gradle-plugin:0.8.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;android &#123; .......... //此处省略基础配置 sourceSets &#123; main &#123; java &#123; srcDir &apos;src/main/java&apos; &#125; proto &#123; //指定probuf文件位置 srcDir &apos;src/main/proto&apos; &#125; &#125; &#125;&#125;protobuf &#123; //protobuf插件编译任务 protoc &#123; artifact = &apos;com.google.protobuf:protoc:3.1.0&apos; &#125; generateProtoTasks &#123; all().each &#123; task -&gt; task.builtins &#123; remove java &#125; task.builtins &#123; java &#123; &apos;src/main/java&apos; &#125; // Add cpp output without any option. // DO NOT omit the braces if you want this builtin to be added. cpp &#123;&#125; &#125; &#125; &#125;&#125; 可参照URemoteSdk build.gradle配置 1.4 URemoteSdk 调试及安装URemoteSdk ，同时支持插件和独立APP的调试，三方APP在遥控器端最终是作为插件运行的。但是插件得方式不利于开发人员调试，所以该SDK同时支持 独立APP调试运行。 前置条件： C_URemoteService.apk 遥控器端Service。 adb push C_URemoteService.apk /system/app 重启遥控器 S_URemoteService.apk 盒子端Service。 adb push S_URemoteService.apk /system/app 重启盒子 1）独立APP调试（独立APP只做调试使用，不做最终安装部署） 通过6.1.1，6.1.2流程接入URemoteSdk后，直接安装或者adb push 都可以，app在data分区还是system分区都可以 2）插件调试，安装 通过6.1.1，6.1.2流程接入URemoteSdk后， adb push 对应APP到sdcard分区根目录。具体名称要和插件HOST程序商议协定。 以上调试和安装都是指双端APK包。 参考样例c_setting 工程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
